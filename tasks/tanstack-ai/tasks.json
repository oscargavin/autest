{
  "library": "tanstack-ai",
  "libraryId": "/tanstack/ai",
  "generatedAt": "2026-01-17T14:39:35.693Z",
  "docs": [
    {
      "id": "doc-001",
      "title": "useChat Hook for Streaming Chat",
      "content": "The useChat hook from @tanstack/ai-react simplifies building chat interfaces in React by handling message streaming and user interactions. It connects to a server or API endpoint to stream responses in real-time, providing a seamless chat experience. This hook is essential for managing chat state and rendering messages dynamically.",
      "codeExamples": [
        "import { useChat, fetchServerSentEvents } from '@tanstack/ai-react';\nconst chat = useChat({ connection: fetchServerSentEvents('/api/chat') });",
        "const { messages, sendMessage, isLoading } = useChat({ connection: fetchServerSentEvents('/api/chat') });"
      ]
    },
    {
      "id": "doc-002",
      "title": "Server-Side Chat with Streaming SSE",
      "content": "TanStack AI supports server-side chat functionality with Server-Sent Events (SSE) for real-time streaming of responses. Using the stream utility or fetchServerSentEvents, you can connect to a server endpoint that handles chat logic and streams AI responses back to the client. This approach is ideal for offloading processing to the server.",
      "codeExamples": [
        "import { useChat, stream } from '@tanstack/ai-react';\nconst chat = useChat({ connection: stream((messages) => serverChatFunction({ messages })) });",
        "import { fetchServerSentEvents } from '@tanstack/ai-react';\nconst connection = fetchServerSentEvents('/api/chat');"
      ]
    },
    {
      "id": "doc-003",
      "title": "Provider Adapters for AI Models",
      "content": "TanStack AI offers tree-shakeable adapters for multiple AI providers like OpenAI, Anthropic, Gemini, and Ollama. Each adapter can be configured with API keys or host details to connect to the respective service, allowing provider-agnostic chat implementations. This flexibility helps developers switch providers without changing core logic.",
      "codeExamples": [
        "import { chat } from '@tanstack/ai';\nimport { openaiText } from '@tanstack/ai-openai';\nconst stream = chat({ adapter: openaiText({ apiKey: 'key' }), model: 'gpt-4o', messages: [] });",
        "import { anthropicText } from '@tanstack/ai-anthropic';\nconst stream = chat({ adapter: anthropicText({ apiKey: 'key' }), model: 'claude-3-5-sonnet-20241022', messages: [] });"
      ]
    },
    {
      "id": "doc-004",
      "title": "Tool Definition and Function Calling",
      "content": "TanStack AI enables defining tools for AI models to call external functions using the toolDefinition utility. Tools are defined with schemas (often using Zod) to validate inputs, allowing the AI to interact with custom logic like fetching weather data. This is powerful for extending AI capabilities with structured function calls.",
      "codeExamples": [
        "import { toolDefinition } from '@tanstack/ai';\nimport { z } from 'zod';\nconst getWeatherDef = toolDefinition({ name: 'get_weather', description: 'Get weather', inputSchema: z.object({ location: z.string() }) });",
        "const getWeather = getWeatherDef.server(async ({ location }) => ({ temperature: 72, conditions: 'sunny' }));"
      ]
    },
    {
      "id": "doc-005",
      "title": "Message Parts Structure",
      "content": "Messages in TanStack AI are composed of parts that can represent different types of content such as text, thinking, or tool calls. This structure allows for rich chat interactions where the AI's reasoning process or function calls can be displayed distinctly. Understanding message parts is key to rendering complex chat UIs.",
      "codeExamples": [
        "message.parts.map((part, idx) => part.type === 'text' ? <span key={idx}>{part.content}</span> : null);",
        "message.parts.map((part, idx) => part.type === 'thinking' ? <div key={idx}>Thinking: {part.content}</div> : null);"
      ]
    },
    {
      "id": "doc-006",
      "title": "Connection Adapters for Streaming",
      "content": "Connection adapters like fetchServerSentEvents in TanStack AI facilitate streaming responses from server endpoints using protocols like SSE. These adapters are used with hooks like useChat to establish real-time communication channels. They are critical for maintaining a responsive chat experience.",
      "codeExamples": [
        "import { fetchServerSentEvents } from '@tanstack/ai-react';\nconst connection = fetchServerSentEvents('/api/chat');",
        "import { useChat } from '@tanstack/ai-react';\nconst chat = useChat({ connection: fetchServerSentEvents('/api/chat') });"
      ]
    }
  ],
  "tasks": [
    {
      "id": "task-001",
      "docTag": "doc-001",
      "description": "Write a function to initialize a chat session using the useChat hook with a basic SSE connection.",
      "difficulty": "easy",
      "testCode": "import { test } from 'node:test';\nimport assert from 'node:assert';\n\n// Mock globals\nlet capturedConnection;\nglobalThis.fetchServerSentEvents = (url) => { capturedConnection = url; return { type: 'sse' }; };\nglobalThis.useChat = (config) => { capturedConnection = config.connection; return { messages: [], sendMessage: () => {}, isLoading: false }; };\n\ntest('initialize chat session with useChat hook', () => {\n  const chat = initializeChat();\n  assert.strictEqual(capturedConnection, '/api/chat');\n  assert.ok(chat.messages);\n  assert.ok(chat.sendMessage);\n});\n\nfunction initializeChat() {\n  return globalThis.useChat({ connection: globalThis.fetchServerSentEvents('/api/chat') });\n}",
      "solutionHint": "Use the useChat hook with fetchServerSentEvents as the connection."
    },
    {
      "id": "task-002",
      "docTag": "doc-001",
      "description": "Write a function to send a message using the useChat hook and handle loading state.",
      "difficulty": "easy",
      "testCode": "import { test } from 'node:test';\nimport assert from 'node:assert';\n\n// Mock globals\nlet capturedMessage;\nglobalThis.useChat = (config) => ({\n  messages: [],\n  sendMessage: (msg) => { capturedMessage = msg; },\n  isLoading: false\n});\n\ntest('send message using useChat hook', () => {\n  const chat = globalThis.useChat({});\n  const result = sendChatMessage(chat, 'Hello AI');\n  assert.strictEqual(capturedMessage, 'Hello AI');\n  assert.strictEqual(result, true);\n});\n\nfunction sendChatMessage(chat, message) {\n  if (!chat.isLoading) {\n    chat.sendMessage(message);\n    return true;\n  }\n  return false;\n}",
      "solutionHint": "Check isLoading before calling sendMessage."
    },
    {
      "id": "task-003",
      "docTag": "doc-001",
      "description": "Write a function to display messages from useChat, formatting role and content.",
      "difficulty": "medium",
      "testCode": "import { test } from 'node:test';\nimport assert from 'node:assert';\n\n// Mock globals\nglobalThis.useChat = () => ({\n  messages: [\n    { id: '1', role: 'user', parts: [{ type: 'text', content: 'Hi' }] },\n    { id: '2', role: 'assistant', parts: [{ type: 'text', content: 'Hello!' }] }\n  ],\n  sendMessage: () => {},\n  isLoading: false\n});\n\ntest('display formatted messages from useChat', () => {\n  const formatted = formatMessages(globalThis.useChat().messages);\n  assert.strictEqual(formatted.length, 2);\n  assert.strictEqual(formatted[0], 'user: Hi');\n  assert.strictEqual(formatted[1], 'assistant: Hello!');\n});\n\nfunction formatMessages(messages) {\n  return messages.map(msg => `${msg.role}: ${msg.parts[0].content}`);\n}",
      "solutionHint": "Map over messages and concatenate role with content from parts."
    },
    {
      "id": "task-004",
      "docTag": "doc-002",
      "description": "Write a function to set up a server-side chat connection using the stream utility.",
      "difficulty": "easy",
      "testCode": "import { test } from 'node:test';\nimport assert from 'node:assert';\n\n// Mock globals\nlet capturedStreamFn;\nglobalThis.stream = (fn) => { capturedStreamFn = fn; return { type: 'stream' }; };\nglobalThis.useChat = (config) => ({ messages: [], sendMessage: () => {}, isLoading: false });\n\ntest('setup server-side chat with stream utility', () => {\n  const chat = setupServerChat();\n  assert.ok(capturedStreamFn);\n  assert.strictEqual(chat.messages.length, 0);\n});\n\nfunction setupServerChat() {\n  return globalThis.useChat({\n    connection: globalThis.stream((messages) => ({ messages }))\n  });\n}",
      "solutionHint": "Use the stream utility as the connection in useChat."
    },
    {
      "id": "task-005",
      "docTag": "doc-002",
      "description": "Write a function to handle SSE connection errors in a chat setup.",
      "difficulty": "medium",
      "testCode": "import { test } from 'node:test';\nimport assert from 'node:assert';\n\n// Mock globals\nlet capturedUrl;\nglobalThis.fetchServerSentEvents = (url) => { capturedUrl = url; throw new Error('Connection failed'); };\nglobalThis.useChat = (config) => {\n  try { config.connection; } catch (e) { return { error: e.message }; }\n  return { messages: [] };\n};\n\ntest('handle SSE connection error in chat setup', () => {\n  const result = setupChatWithErrorHandling();\n  assert.strictEqual(result.error, 'Connection failed');\n  assert.strictEqual(capturedUrl, '/api/chat');\n});\n\nfunction setupChatWithErrorHandling() {\n  return globalThis.useChat({ connection: globalThis.fetchServerSentEvents('/api/chat') });\n}",
      "solutionHint": "Wrap connection setup to catch errors from fetchServerSentEvents."
    },
    {
      "id": "task-006",
      "docTag": "doc-003",
      "description": "Write a function to initialize a chat stream with OpenAI adapter.",
      "difficulty": "easy",
      "testCode": "import { test } from 'node:test';\nimport assert from 'node:assert';\n\n// Mock globals\nlet capturedAdapter;\nglobalThis.openaiText = (config) => { capturedAdapter = config; return { type: 'openai' }; };\nglobalThis.chat = (config) => { capturedAdapter = config.adapter; return { stream: true }; };\n\ntest('initialize chat with OpenAI adapter', () => {\n  const stream = initOpenAIChat('my-key');\n  assert.strictEqual(capturedAdapter.apiKey, 'my-key');\n  assert.ok(stream.stream);\n});\n\nfunction initOpenAIChat(apiKey) {\n  return globalThis.chat({\n    adapter: globalThis.openaiText({ apiKey }),\n    model: 'gpt-4o',\n    messages: []\n  });\n}",
      "solutionHint": "Use openaiText adapter with chat function."
    },
    {
      "id": "task-007",
      "docTag": "doc-003",
      "description": "Write a function to switch between multiple provider adapters dynamically.",
      "difficulty": "medium",
      "testCode": "import { test } from 'node:test';\nimport assert from 'node:assert';\n\n// Mock globals\nlet capturedProvider;\nglobalThis.openaiText = () => ({ type: 'openai' });\nglobalThis.anthropicText = () => ({ type: 'anthropic' });\nglobalThis.chat = (config) => { capturedProvider = config.adapter.type; return { stream: true }; };\n\ntest('switch between provider adapters dynamically', () => {\n  const stream1 = selectProviderChat('openai');\n  assert.strictEqual(capturedProvider, 'openai');\n  const stream2 = selectProviderChat('anthropic');\n  assert.strictEqual(capturedProvider, 'anthropic');\n});\n\nfunction selectProviderChat(provider) {\n  const adapters = {\n    openai: globalThis.openaiText(),\n    anthropic: globalThis.anthropicText()\n  };\n  return globalThis.chat({\n    adapter: adapters[provider],\n    model: provider === 'openai' ? 'gpt-4o' : 'claude-3-5-sonnet',\n    messages: []\n  });\n}",
      "solutionHint": "Use an object to map providers to adapters and models."
    },
    {
      "id": "task-008",
      "docTag": "doc-003",
      "description": "Write a function to configure Ollama adapter for local model usage with custom host.",
      "difficulty": "medium",
      "testCode": "import { test } from 'node:test';\nimport assert from 'node:assert';\n\n// Mock globals\nlet capturedHost;\nglobalThis.ollamaText = (config) => { capturedHost = config.host; return { type: 'ollama' }; };\nglobalThis.chat = (config) => ({ stream: true });\n\ntest('configure Ollama adapter with custom host', () => {\n  const stream = setupOllamaChat('http://localhost:11434');\n  assert.strictEqual(capturedHost, 'http://localhost:11434');\n  assert.ok(stream.stream);\n});\n\nfunction setupOllamaChat(host) {\n  return globalThis.chat({\n    adapter: globalThis.ollamaText({ host }),\n    model: 'llama3.2',\n    messages: []\n  });\n}",
      "solutionHint": "Pass host to ollamaText adapter configuration."
    },
    {
      "id": "task-009",
      "docTag": "doc-004",
      "description": "Write a function to define a simple tool using toolDefinition with Zod schema.",
      "difficulty": "easy",
      "testCode": "import { test } from 'node:test';\nimport assert from 'node:assert';\n\n// Mock globals\nlet capturedTool;\nglobalThis.toolDefinition = (config) => { capturedTool = config; return { name: config.name }; };\nglobalThis.z = { object: (schema) => schema, string: () => ({}) };\n\ntest('define a tool with toolDefinition and Zod schema', () => {\n  const tool = defineWeatherTool();\n  assert.strictEqual(capturedTool.name, 'get_weather');\n  assert.ok(capturedTool.inputSchema.location);\n});\n\nfunction defineWeatherTool() {\n  return globalThis.toolDefinition({\n    name: 'get_weather',\n    description: 'Get current weather',\n    inputSchema: globalThis.z.object({ location: globalThis.z.string() })\n  });\n}",
      "solutionHint": "Use toolDefinition with a Zod object schema."
    },
    {
      "id": "task-010",
      "docTag": "doc-004",
      "description": "Write a function to implement server-side logic for a tool defined with toolDefinition.",
      "difficulty": "medium",
      "testCode": "import { test } from 'node:test';\nimport assert from 'node:assert';\n\n// Mock globals\nlet capturedServerFn;\nglobalThis.toolDefinition = (config) => ({ name: config.name, server: (fn) => { capturedServerFn = fn; return { name: config.name }; } });\nglobalThis.z = { object: () => ({}) };\n\ntest('implement server logic for a tool', async () => {\n  const tool = implementWeatherTool();\n  const result = await capturedServerFn({ location: 'NY' });\n  assert.strictEqual(result.temperature, 72);\n  assert.strictEqual(result.conditions, 'sunny');\n});\n\nfunction implementWeatherTool() {\n  const toolDef = globalThis.toolDefinition({ name: 'get_weather', description: 'Get weather', inputSchema: globalThis.z.object({}) });\n  return toolDef.server(async ({ location }) => ({ temperature: 72, conditions: 'sunny' }));\n}",
      "solutionHint": "Use the server method on toolDefinition to define logic."
    },
    {
      "id": "task-011",
      "docTag": "doc-004",
      "description": "Write a function to integrate a tool into a chat stream with OpenAI adapter.",
      "difficulty": "hard",
      "testCode": "import { test } from 'node:test';\nimport assert from 'node:assert';\n\n// Mock globals\nlet capturedTools;\nglobalThis.openaiText = () => ({ type: 'openai' });\nglobalThis.chat = (config) => { capturedTools = config.tools; return { stream: true }; };\nglobalThis.toolDefinition = (config) => ({ name: config.name, server: (fn) => ({ name: config.name }) });\nglobalThis.z = { object: () => ({}) };\n\ntest('integrate tool into chat stream', () => {\n  const stream = setupChatWithTool();\n  assert.strictEqual(capturedTools.length, 1);\n  assert.strictEqual(capturedTools[0].name, 'get_weather');\n});\n\nfunction setupChatWithTool() {\n  const tool = globalThis.toolDefinition({ name: 'get_weather', description: 'Get weather', inputSchema: globalThis.z.object({}) }).server(async () => ({}));\n  return globalThis.chat({\n    adapter: globalThis.openaiText(),\n    model: 'gpt-4o',\n    messages: [],\n    tools: [tool]\n  });\n}",
      "solutionHint": "Pass the tool in the tools array of the chat config."
    },
    {
      "id": "task-012",
      "docTag": "doc-005",
      "description": "Write a function to extract text content from message parts.",
      "difficulty": "easy",
      "testCode": "import { test } from 'node:test';\nimport assert from 'node:assert';\n\ntest('extract text content from message parts', () => {\n  const message = {\n    parts: [\n      { type: 'text', content: 'Hello' },\n      { type: 'thinking', content: 'Thinking...' }\n    ]\n  };\n  const text = extractTextContent(message);\n  assert.strictEqual(text, 'Hello');\n});\n\nfunction extractTextContent(message) {\n  const textPart = message.parts.find(part => part.type === 'text');\n  return textPart ? textPart.content : '';\n}",
      "solutionHint": "Use find to locate the text part and return its content."
    },
    {
      "id": "task-013",
      "docTag": "doc-005",
      "description": "Write a function to render thinking parts of a message as italic text.",
      "difficulty": "easy",
      "testCode": "import { test } from 'node:test';\nimport assert from 'node:assert';\n\ntest('render thinking parts as italic text', () => {\n  const message = {\n    parts: [\n      { type: 'text', content: 'Hello' },\n      { type: 'thinking', content: 'Thinking...' }\n    ]\n  };\n  const thinking = renderThinking(message);\n  assert.strictEqual(thinking, '<i>Thinking...</i>');\n});\n\nfunction renderThinking(message) {\n  const thinkingPart = message.parts.find(part => part.type === 'thinking');\n  return thinkingPart ? `<i>${thinkingPart.content}</i>` : '';\n}",
      "solutionHint": "Find thinking part and wrap content in italic tags."
    },
    {
      "id": "task-014",
      "docTag": "doc-005",
      "description": "Write a function to handle all message part types with custom formatting.",
      "difficulty": "medium",
      "testCode": "import { test } from 'node:test';\nimport assert from 'node:assert';\n\ntest('handle all message part types with formatting', () => {\n  const message = {\n    parts: [\n      { type: 'text', content: 'Hello' },\n      { type: 'thinking', content: 'Thinking...' },\n      { type: 'tool_call', content: 'Calling tool' }\n    ]\n  };\n  const formatted = formatMessageParts(message);\n  assert.strictEqual(formatted.length, 3);\n  assert.strictEqual(formatted[0], 'Hello');\n  assert.strictEqual(formatted[1], 'Thinking: Thinking...');\n  assert.strictEqual(formatted[2], 'Tool: Calling tool');\n});\n\nfunction formatMessageParts(message) {\n  return message.parts.map(part => {\n    if (part.type === 'text') return part.content;\n    if (part.type === 'thinking') return `Thinking: ${part.content}`;\n    if (part.type === 'tool_call') return `Tool: ${part.content}`;\n    return '';\n  }).filter(Boolean);\n}",
      "solutionHint": "Map over parts and apply type-specific formatting."
    },
    {
      "id": "task-015",
      "docTag": "doc-006",
      "description": "Write a function to initialize a connection adapter with fetchServerSentEvents.",
      "difficulty": "easy",
      "testCode": "import { test } from 'node:test';\nimport assert from 'node:assert';\n\n// Mock globals\nlet capturedUrl;\nglobalThis.fetchServerSentEvents = (url) => { capturedUrl = url; return { type: 'sse' }; };\n\ntest('initialize connection with fetchServerSentEvents', () => {\n  const connection = initConnection('/api/chat');\n  assert.strictEqual(capturedUrl, '/api/chat');\n  assert.strictEqual(connection.type, 'sse');\n});\n\nfunction initConnection(url) {\n  return globalThis.fetchServerSentEvents(url);\n}",
      "solutionHint": "Call fetchServerSentEvents with the API URL."
    },
    {
      "id": "task-016",
      "docTag": "doc-006",
      "description": "Write a function to retry connection adapter setup on failure.",
      "difficulty": "medium",
      "testCode": "import { test } from 'node:test';\nimport assert from 'node:assert';\n\n// Mock globals\nlet connectionAttempts = 0;\nglobalThis.fetchServerSentEvents = (url) => {\n  connectionAttempts++;\n  if (connectionAttempts < 2) throw new Error('Failed');\n  return { type: 'sse' };\n};\n\ntest('retry connection adapter setup on failure', () => {\n  const connection = retryConnection('/api/chat', 2);\n  assert.strictEqual(connectionAttempts, 2);\n  assert.strictEqual(connection.type, 'sse');\n});\n\nfunction retryConnection(url, maxRetries) {\n  for (let i = 0; i < maxRetries; i++) {\n    try {\n      return globalThis.fetchServerSentEvents(url);\n    } catch (e) {\n      if (i === maxRetries - 1) throw e;\n    }\n  }\n}",
      "solutionHint": "Use a loop to retry fetchServerSentEvents up to max retries."
    },
    {
      "id": "task-017",
      "docTag": "doc-001",
      "description": "Write a function to handle multiple chat sessions with useChat hook.",
      "difficulty": "hard",
      "testCode": "import { test } from 'node:test';\nimport assert from 'node:assert';\n\n// Mock globals\nlet capturedConnections = [];\nglobalThis.fetchServerSentEvents = (url) => { capturedConnections.push(url); return { type: 'sse' }; };\nglobalThis.useChat = (config) => ({ messages: [], sendMessage: () => {}, id: config.connection });\n\ntest('handle multiple chat sessions with useChat', () => {\n  const sessions = createChatSessions(['/api/chat1', '/api/chat2']);\n  assert.strictEqual(sessions.length, 2);\n  assert.strictEqual(capturedConnections.length, 2);\n  assert.strictEqual(capturedConnections[0], '/api/chat1');\n  assert.strictEqual(capturedConnections[1], '/api/chat2');\n});\n\nfunction createChatSessions(urls) {\n  return urls.map(url => globalThis.useChat({ connection: globalThis.fetchServerSentEvents(url) }));\n}",
      "solutionHint": "Map over URLs to create separate useChat instances."
    },
    {
      "id": "task-018",
      "docTag": "doc-002",
      "description": "Write a function to log server-side streaming events for debugging.",
      "difficulty": "medium",
      "testCode": "import { test } from 'node:test';\nimport assert from 'node:assert';\n\n// Mock globals\nlet capturedLogs = [];\nglobalThis.stream = (fn) => ({ type: 'stream', onEvent: (cb) => { cb('event1'); cb('event2'); } });\nglobalThis.useChat = (config) => ({ messages: [], sendMessage: () => {} });\n\ntest('log server-side streaming events', () => {\n  setupStreamWithLogging();\n  assert.strictEqual(capturedLogs.length, 2);\n  assert.strictEqual(capturedLogs[0], 'event1');\n  assert.strictEqual(capturedLogs[1], 'event2');\n});\n\nfunction setupStreamWithLogging() {\n  const connection = globalThis.stream(() => ({}));\n  connection.onEvent((event) => capturedLogs.push(event));\n  return globalThis.useChat({ connection });\n}",
      "solutionHint": "Attach an event listener to the stream connection."
    },
    {
      "id": "task-019",
      "docTag": "doc-003",
      "description": "Write a function to handle provider adapter errors gracefully.",
      "difficulty": "hard",
      "testCode": "import { test } from 'node:test';\nimport assert from 'node:assert';\n\n// Mock globals\nlet capturedFallback;\nglobalThis.openaiText = () => { throw new Error('API key missing'); };\nglobalThis.anthropicText = () => ({ type: 'anthropic' });\nglobalThis.chat = (config) => ({ stream: true });\n\ntest('handle provider adapter errors with fallback', () => {\n  const stream = setupProviderWithFallback('openai', 'anthropic');\n  assert.strictEqual(capturedFallback, 'anthropic');\n  assert.ok(stream.stream);\n});\n\nfunction setupProviderWithFallback(primary, fallback) {\n  let adapter;\n  try {\n    adapter = primary === 'openai' ? globalThis.openaiText() : globalThis.anthropicText();\n  } catch (e) {\n    capturedFallback = fallback;\n    adapter = fallback === 'anthropic' ? globalThis.anthropicText() : globalThis.openaiText();\n  }\n  return globalThis.chat({ adapter, model: 'model', messages: [] });\n}",
      "solutionHint": "Use try-catch to fallback to another provider on error."
    },
    {
      "id": "task-020",
      "docTag": "doc-006",
      "description": "Write a function to handle connection adapter timeouts.",
      "difficulty": "hard",
      "testCode": "import { test } from 'node:test';\nimport assert from 'node:assert';\n\n// Mock globals\nlet capturedTimeout;\nglobalThis.fetchServerSentEvents = (url, options) => { capturedTimeout = options.timeout; return { type: 'sse' }; };\n\ntest('handle connection adapter timeouts', () => {\n  const connection = setupConnectionWithTimeout('/api/chat', 5000);\n  assert.strictEqual(capturedTimeout, 5000);\n  assert.strictEqual(connection.type, 'sse');\n});\n\nfunction setupConnectionWithTimeout(url, timeout) {\n  return globalThis.fetchServerSentEvents(url, { timeout });\n}",
      "solutionHint": "Pass a timeout option to fetchServerSentEvents."
    }
  ]
}