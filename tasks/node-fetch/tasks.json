{
  "library": "node-fetch",
  "libraryId": "/node/fetch",
  "generatedAt": "2026-01-17T14:55:57.643Z",
  "docs": [
    {
      "id": "fetch-basics",
      "title": "Basic Fetch Requests",
      "content": "The fetch() function makes HTTP requests returning a Promise<Response>. Specify method, headers, and body in options for different request types. Check response.ok and status after fetch resolves.",
      "codeExamples": [
        "const res = await fetch('https://example.com');\nif (res.ok) console.log(await res.text());",
        "const res = await fetch('https://example.com', { method: 'POST', body: JSON.stringify({key: 'value'}) });"
      ]
    },
    {
      "id": "response-consume",
      "title": "Consuming Response Body",
      "content": "Use response.text(), json(), or arrayBuffer() to parse the entire body. For efficiency, stream with response.body as ReadableStream supporting async iteration.",
      "codeExamples": [
        "const data = await response.json();",
        "for await (const chunk of response.body) { process(chunk); }"
      ]
    },
    {
      "id": "stream-methods",
      "title": "Readable Stream Processing Methods",
      "content": "Readable streams provide forEach, map, filter, reduce for async chunk processing. These methods handle promises returned by callbacks and manage backpressure.",
      "codeExamples": [
        "await readable.forEach(chunk => console.log(chunk));",
        "const result = await readable.map(chunk => chunk.toUpperCase()).toArray();"
      ]
    },
    {
      "id": "stream-pipeline",
      "title": "Chaining Streams with pipeline",
      "content": "stream.pipeline() sequences streams and auto-closes on errors. Useful for fetch response.body to transforms or writables, but avoid with requests to prevent premature socket close.",
      "codeExamples": [
        "import { pipeline } from 'node:stream';\nawait pipeline(response.body, writable);",
        "pipeline(readable, transform, writable, err => { if (err) throw err; });"
      ]
    },
    {
      "id": "undici-client",
      "title": "Undici Client for Connection Reuse",
      "content": "Undici's Client pools connections for a base URL, supporting HTTP/2 over TLS. Configure with options like keepAlive and headers for repeated requests.",
      "codeExamples": [
        "import { Client } from 'undici';\nconst client = new Client('https://example.com');\nconst res = await client.request({ path: '/api' });",
        "const client = new Client('https://example.com', { keepAliveTimeout: 1000 });"
      ]
    },
    {
      "id": "proxy-agent",
      "title": "Proxy Support with ProxyAgent",
      "content": "ProxyAgent routes requests via a proxy, configurable as dispatcher option or global. Supports HTTP proxies and per-request overrides.",
      "codeExamples": [
        "import { ProxyAgent } from 'undici';\nconst agent = new ProxyAgent('http://proxy:8080');\nfetch(url, { dispatcher: agent });",
        "globalThis.fetch = (url, opts) => undici.fetch(url, { ...opts, dispatcher: agent });"
      ]
    }
  ],
  "tasks": [
    {
      "id": "task-001",
      "docTag": "fetch-basics",
      "description": "Write a function getStatus(url) that fetches the URL and returns the status code.",
      "difficulty": "easy",
      "testCode": "import { test } from 'node:test';\nimport assert from 'node:assert';\nlet captured;\nglobalThis.fetch = async (u, o) => {\n  captured = { u, o };\n  return new Response(null, { status: 200 });\n};\n\ntest('getStatus returns 200', async () => {\n  const result = await getStatus('https://test.com');\n  assert.strictEqual(result, 200);\n  assert.strictEqual(captured.u, 'https://test.com');\n});\n\ntest('getStatus handles 404', async () => {\n  globalThis.fetch = async () => new Response(null, { status: 404 });\n  const result = await getStatus('https://fail.com');\n  assert.strictEqual(result, 404);\n});",
      "solutionHint": "Call fetch(url) then return response.status"
    },
    {
      "id": "task-002",
      "docTag": "fetch-basics",
      "description": "Write a function postData(url, data) that POSTs JSON data and returns true if response.ok.",
      "difficulty": "easy",
      "testCode": "import { test } from 'node:test';\nimport assert from 'node:assert';\nlet captured;\nglobalThis.fetch = async (u, o) => {\n  captured = { u, o };\n  return new Response('ok', { status: 201 });\n};\n\ntest('postData succeeds', async () => {\n  const result = await postData('https://test.com', { foo: 'bar' });\n  assert.strictEqual(result, true);\n  assert.strictEqual(captured.u, 'https://test.com');\n  assert.deepStrictEqual(captured.o.method, 'POST');\n  assert.deepStrictEqual(captured.o.headers.get('Content-Type'), 'application/json');\n});",
      "solutionHint": "Use fetch with {method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify(data)} then response.ok"
    },
    {
      "id": "task-003",
      "docTag": "fetch-basics",
      "description": "Write a function fetchWithHeaders(url, customHeaders) that adds custom headers to a GET request.",
      "difficulty": "medium",
      "testCode": "import { test } from 'node:test';\nimport assert from 'node:assert';\nlet captured;\nglobalThis.fetch = async (u, o) => { captured = { u, o }; return new Response('ok'); };\n\ntest('adds headers', async () => {\n  await fetchWithHeaders('https://test.com', new Headers({ 'X-Custom': 'value' }));\n  assert.strictEqual(captured.o.headers.get('X-Custom'), 'value');\n});",
      "solutionHint": "Pass Headers object in options.headers"
    },
    {
      "id": "task-004",
      "docTag": "fetch-basics",
      "description": "Write a function conditionalFetch(url, condition) that only fetches if condition is truthy, else returns null.",
      "difficulty": "medium",
      "testCode": "import { test } from 'node:test';\nimport assert from 'node:assert';\nlet called = false;\nglobalThis.fetch = async () => { called = true; return new Response('ok'); };\n\ntest('fetches when true', async () => {\n  const result = await conditionalFetch('https://test.com', true);\n  assert.ok(result);\n  assert.strictEqual(called, true);\n});\n\ntest('skips when false', async () => {\n  called = false;\n  const result = await conditionalFetch('https://test.com', false);\n  assert.strictEqual(result, null);\n  assert.strictEqual(called, false);\n});",
      "solutionHint": "If/else around fetch based on condition"
    },
    {
      "id": "task-005",
      "docTag": "response-consume",
      "description": "Write a function getJson(url) that fetches and parses JSON body.",
      "difficulty": "easy",
      "testCode": "import { test } from 'node:test';\nimport assert from 'node:assert';\nlet captured;\nglobalThis.fetch = async (u) => {\n  captured = u;\n  return new Response(JSON.stringify({ key: 'value' }));\n};\n\ntest('parses json', async () => {\n  const result = await getJson('https://test.com');\n  assert.deepStrictEqual(result, { key: 'value' });\n});",
      "solutionHint": "await response.json()"
    },
    {
      "id": "task-006",
      "docTag": "response-consume",
      "description": "Write a function getText(url) that fetches and returns response text only if status < 400.",
      "difficulty": "easy",
      "testCode": "import { test } from 'node:test';\nimport assert from 'node:assert';\nglobalThis.fetch = async () => new Response('hello');\n\ntest('returns text', async () => {\n  const result = await getText('https://test.com');\n  assert.strictEqual(result, 'hello');\n});",
      "solutionHint": "If response.ok then await response.text()"
    },
    {
      "id": "task-007",
      "docTag": "response-consume",
      "description": "Write a function streamAll(url) that reads entire response.body via async iterator and concatenates chunks.",
      "difficulty": "medium",
      "testCode": "import { test } from 'node:test';\nimport assert from 'node:assert';\nlet chunks = [];\nglobalThis.Response = class extends globalThis.Response {\n  get body() { return { [Symbol.asyncIterator]: async function*() { yield* chunks; } }; }\n};\nchunks = ['hel', 'lo'];\n\ntest('streams all', async () => {\n  const result = await streamAll('https://test.com');\n  assert.strictEqual(result, 'hello');\n});",
      "solutionHint": "Use for await...of response.body then join chunks"
    },
    {
      "id": "task-008",
      "docTag": "stream-methods",
      "description": "Write a function streamForEach(url, fn) that applies fn to each chunk in response.body.",
      "difficulty": "easy",
      "testCode": "import { test } from 'node:test';\nimport assert from 'node:assert';\nlet fnCalls = [];\nglobalThis.fetch = async () => {\n  const body = { [Symbol.asyncIterator]: async function*() { yield 'a'; yield 'b'; } };\n  return new Response(null, { body });\n};\nconst mockFn = (c) => fnCalls.push(c);\n\ntest('calls fn per chunk', async () => {\n  await streamForEach('https://test.com', mockFn);\n  assert.deepStrictEqual(fnCalls, ['a', 'b']);\n});",
      "solutionHint": "await response.body.forEach(fn)"
    },
    {
      "id": "task-009",
      "docTag": "stream-methods",
      "description": "Write a function streamMap(url, transformFn) that maps chunks and returns array.",
      "difficulty": "medium",
      "testCode": "import { test } from 'node:test';\nimport assert from 'node:assert';\nglobalThis.fetch = async () => {\n  const body = { [Symbol.asyncIterator]: async function*() { yield 'a'; yield 'b'; } };\n  return new Response(null, { body });\n};\n\ntest('maps chunks', async () => {\n  const result = await streamMap('https://test.com', c => c.toUpperCase());\n  assert.deepStrictEqual(result, ['A', 'B']);\n});",
      "solutionHint": "await response.body.map(fn).toArray()"
    },
    {
      "id": "task-010",
      "docTag": "stream-methods",
      "description": "Write a function streamFilter(url, predFn) that filters chunks and concatenates them.",
      "difficulty": "medium",
      "testCode": "import { test } from 'node:test';\nimport assert from 'node:assert';\nglobalThis.fetch = async () => {\n  const body = { [Symbol.asyncIterator]: async function*() { yield 'a'; yield 'b'; yield 'a'; } };\n  return new Response(null, { body });\n};\n\ntest('filters and joins', async () => {\n  const result = await streamFilter('https://test.com', c => c === 'a');\n  assert.strictEqual(result, 'aa');\n});",
      "solutionHint": "await response.body.filter(fn).toArray() then join"
    },
    {
      "id": "task-011",
      "docTag": "stream-methods",
      "description": "Write a function streamReduce(url, reducer, init) that reduces stream chunks.",
      "difficulty": "hard",
      "testCode": "import { test } from 'node:test';\nimport assert from 'node:assert';\nglobalThis.fetch = async () => {\n  const body = { [Symbol.asyncIterator]: async function*() { yield 1; yield 2; yield 3; } };\n  return new Response(null, { body });\n};\n\ntest('reduces sum', async () => {\n  const result = await streamReduce('https://test.com', (acc, n) => acc + n, 0);\n  assert.strictEqual(result, 6);\n});",
      "solutionHint": "await response.body.reduce(reducer, init)"
    },
    {
      "id": "task-012",
      "docTag": "stream-pipeline",
      "description": "Write a function pipeToWritable(url, writable) that pipelines response.body to a writable stream.",
      "difficulty": "medium",
      "testCode": "import { test } from 'node:test';\nimport assert from 'node:assert';\nimport { pipeline } from 'node:stream';\nlet written = [];\nconst mockWritable = new (class { write(c, cb) { written.push(c); cb(); } end(cb) { cb(); } })();\nglobalThis.fetch = async () => {\n  const body = { pipeTo: async (w) => { await pipeline(body, w); } };\n  return new Response(null, { body });\n};\n\ntest('pipelines', async () => {\n  await pipeToWritable('https://test.com', mockWritable);\n  assert.strictEqual(written.length > 0, true);\n});",
      "solutionHint": "import {pipeline} from 'stream'; await pipeline(response.body, writable)"
    },
    {
      "id": "task-013",
      "docTag": "stream-pipeline",
      "description": "Write a function safePipeline(url, transformFn) that pipelines response.body through a transform and handles errors.",
      "difficulty": "hard",
      "testCode": "import { test } from 'node:test';\nimport assert from 'node:assert';\nlet errored = false;\nglobalThis.fetch = async () => new Response('data');\n\ntest('handles no error', async () => {\n  await safePipeline('https://test.com', (c, enc, cb) => cb(null, c.toUpperCase()));\n  assert.strictEqual(errored, false);\n});\n\ntest('handles error', async () => {\n  globalThis.fetch = async () => { throw new Error('fail'); };\n  await safePipeline('https://test.com', () => { throw new Error(); });\n});",
      "solutionHint": "Use pipeline with callback for err handling"
    },
    {
      "id": "task-014",
      "docTag": "undici-client",
      "description": "Write a function createClient(baseUrl) that returns a new Undici Client.",
      "difficulty": "easy",
      "testCode": "import { test } from 'node:test';\nimport assert from 'node:assert';\nlet captured;\nclass MockClient { constructor(u, o) { captured = {u, o}; } async request(p) { return new Response('ok'); } }\nglobalThis.Client = MockClient;\n\ntest('creates client', () => {\n  const client = createClient('https://example.com');\n  assert.ok(client instanceof MockClient);\n  assert.strictEqual(captured.u, 'https://example.com');\n});",
      "solutionHint": "new Client(baseUrl)"
    },
    {
      "id": "task-015",
      "docTag": "undici-client",
      "description": "Write a function clientGet(client, path) that requests the path with GET.",
      "difficulty": "easy",
      "testCode": "import { test } from 'node:test';\nimport assert from 'node:assert';\nlet captured;\nconst mockClient = { request: async (opts) => { captured = opts; return new Response('ok'); } };\n\ntest('requests path', async () => {\n  await clientGet(mockClient, '/api');\n  assert.strictEqual(captured.path, '/api');\n  assert.strictEqual(captured.method, 'GET');\n});",
      "solutionHint": "await client.request({path, method:'GET'})"
    },
    {
      "id": "task-016",
      "docTag": "undici-client",
      "description": "Write a function pooledRequests(client, paths) that fetches multiple paths sequentially.",
      "difficulty": "medium",
      "testCode": "import { test } from 'node:test';\nimport assert from 'node:assert';\nlet calls = [];\nconst mockClient = { async request(opts) { calls.push(opts.path); return new Response('ok'); } };\n\ntest('multiple requests', async () => {\n  await pooledRequests(mockClient, ['/1', '/2']);\n  assert.deepStrictEqual(calls, ['/1', '/2']);\n});",
      "solutionHint": "Loop await client.request({path})"
    },
    {
      "id": "task-017",
      "docTag": "proxy-agent",
      "description": "Write a function createProxyAgent(proxyUrl) that returns new ProxyAgent.",
      "difficulty": "easy",
      "testCode": "import { test } from 'node:test';\nimport assert from 'node:assert';\nlet captured;\nclass MockProxyAgent { constructor(u) { captured = u; } }\nglobalThis.ProxyAgent = MockProxyAgent;\n\ntest('creates agent', () => {\n  const agent = createProxyAgent('http://proxy');\n  assert.strictEqual(captured, 'http://proxy');\n});",
      "solutionHint": "new ProxyAgent(proxyUrl)"
    },
    {
      "id": "task-018",
      "docTag": "proxy-agent",
      "description": "Write a function fetchViaProxy(url, proxyUrl) that fetches using ProxyAgent.",
      "difficulty": "medium",
      "testCode": "import { test } from 'node:test';\nimport assert from 'node:assert';\nlet capturedOpts;\nglobalThis.fetch = async (u, o) => { capturedOpts = o; return new Response('ok'); };\nclass MockProxyAgent { constructor() {} }\nglobalThis.ProxyAgent = MockProxyAgent;\n\ntest('uses dispatcher', async () => {\n  await fetchViaProxy('https://test.com', 'http://proxy');\n  assert.ok(capturedOpts.dispatcher instanceof MockProxyAgent);\n});",
      "solutionHint": "const agent = new ProxyAgent(proxyUrl); fetch(url, {dispatcher: agent})"
    },
    {
      "id": "task-019",
      "docTag": "proxy-agent",
      "description": "Write a function setGlobalProxy(proxyUrl) that sets ProxyAgent as global fetch dispatcher.",
      "difficulty": "hard",
      "testCode": "import { test } from 'node:test';\nimport assert from 'node:assert';\nlet originalFetch;\nclass MockProxyAgent { constructor() {} }\nglobalThis.ProxyAgent = MockProxyAgent;\n\ntest('sets global', async () => {\n  setGlobalProxy('http://proxy');\n  originalFetch = globalThis.fetch;\n  assert.ok(globalThis.fetch.toString().includes('dispatcher'));\n});",
      "solutionHint": "const agent=new ProxyAgent(); replace globalThis.fetch to use {dispatcher:agent}"
    },
    {
      "id": "task-020",
      "docTag": "stream-pipeline",
      "description": "Write a function pipelineWithTransform(url, transform) that pipelines body through a custom transform stream.",
      "difficulty": "hard",
      "testCode": "import { test } from 'node:test';\nimport assert from 'node:assert';\nlet transformCalled = false;\nconst mockTransform = new (class extends TransformStream { transform(c,_,cb){ transformCalled=true; cb(null,c.toUpperCase()); } })();\nglobalThis.fetch = async () => new Response('hello');\n\ntest('pipelines transform', async () => {\n  await pipelineWithTransform('https://test.com', mockTransform);\n  assert.strictEqual(transformCalled, true);\n});",
      "solutionHint": "pipeline(response.body, transform, ...)"
    },
    {
      "id": "task-021",
      "docTag": "undici-client",
      "description": "Write a function clientPost(client, path, body) that POSTs body to path using client.",
      "difficulty": "medium",
      "testCode": "import { test } from 'node:test';\nimport assert from 'node:assert';\nlet captured;\nconst mockClient = { async request(opts) { captured = opts; return new Response('ok'); } };\n\ntest('posts data', async () => {\n  await clientPost(mockClient, '/api', 'data');\n  assert.strictEqual(captured.path, '/api');\n  assert.strictEqual(captured.method, 'POST');\n  assert.strictEqual(captured.body, 'data');\n});",
      "solutionHint": "client.request({path, method:'POST', body})"
    },
    {
      "id": "task-022",
      "docTag": "response-consume",
      "description": "Write a function getFirstChunk(url) that returns the first chunk from response.body.",
      "difficulty": "hard",
      "testCode": "import { test } from 'node:test';\nimport assert from 'node:assert';\nlet iter;\nglobalThis.fetch = async () => {\n  iter = (async function*() { yield 'first'; })();\n  return new Response(null, { body: { [Symbol.asyncIterator]: () => iter } });\n};\n\ntest('gets first', async () => {\n  const result = await getFirstChunk('https://test.com');\n  assert.strictEqual(result, 'first');\n});",
      "solutionHint": "const it=response.body[Symbol.asyncIterator](); const {value}=await it.next();"
    },
    {
      "id": "task-023",
      "docTag": "stream-methods",
      "description": "Write a function streamToLines(url) that splits stream chunks by '\\n' into array of lines.",
      "difficulty": "hard",
      "testCode": "import { test } from 'node:test';\nimport assert from 'node:assert';\nglobalThis.fetch = async () => {\n  const body = { map: async (fn) => ({ toArray: async () => ['line1\\n', 'line2'].flatMap(l => l.split('\\n')).filter(Boolean) }) };\n  return new Response(null, { body });\n};\n\ntest('splits lines', async () => {\n  const result = await streamToLines('https://test.com');\n  assert.deepStrictEqual(result, ['line1', 'line2']);\n});",
      "solutionHint": "Use map to split chunk by '\\n' and flat"
    }
  ]
}