{"messages":[{"role":"system","content":"You are an expert programmer. Write clean, working code."},{"role":"user","content":"## useStdout Hook\n\nThe useStdout hook provides access to the stdout stream and a write method for printing strings above Ink's main output area without disrupting the UI rendering. It returns an object containing the stdout stream and the write function. This is particularly useful for logging status updates or informational messages in CLI apps.\n\n```typescript\nimport {useStdout} from 'ink';\nconst {write} = useStdout();\nwrite('Hello from stdout\\n');\n\nimport React, {useEffect} from 'react';\nimport {useStdout} from 'ink';\nconst Demo = () => {\n  const {write} = useStdout();\n  useEffect(() => write('Logged on mount\\n'), []);\n  return null;\n};\n```\n\n---\n\nWrite code to solve this task:\n\nWrite a function logMessage(msg) that uses useStdout to write the given message followed by a newline.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nlet captured;\nconst mockWrite = (text) => { captured = text; };\nglobalThis.useStdout = () => ({ write: mockWrite });\n\nfunctionUnderTest('Hello World');\n\nassert.strictEqual(captured, 'Hello World\\n');\n```\n\nReturn ONLY the code, no explanations."},{"role":"assistant","content":"function functionUnderTest(msg) {\n\tconst { write } = useStdout();\n\twrite(`${msg}\\n`);\n}"}]}
{"messages":[{"role":"system","content":"You are an expert programmer. Write clean, working code."},{"role":"user","content":"## useStdout Hook\n\nThe useStdout hook provides access to the stdout stream and a write method for printing strings above Ink's main output area without disrupting the UI rendering. It returns an object containing the stdout stream and the write function. This is particularly useful for logging status updates or informational messages in CLI apps.\n\n```typescript\nimport {useStdout} from 'ink';\nconst {write} = useStdout();\nwrite('Hello from stdout\\n');\n\nimport React, {useEffect} from 'react';\nimport {useStdout} from 'ink';\nconst Demo = () => {\n  const {write} = useStdout();\n  useEffect(() => write('Logged on mount\\n'), []);\n  return null;\n};\n```\n\n---\n\nWrite code to solve this task:\n\nWrite a function logMultiple(messages) that logs each message in the array using useStdout.write.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nlet captured = [];\nconst mockWrite = (text) => { captured.push(text); };\nglobalThis.useStdout = () => ({ write: mockWrite });\n\nfunctionUnderTest(['msg1', 'msg2']);\n\nassert.deepStrictEqual(captured, ['msg1\\n', 'msg2\\n']);\n```\n\nReturn ONLY the code, no explanations."},{"role":"assistant","content":"function functionUnderTest(messages) {\n  const {write} = useStdout();\n  for (const message of messages) {\n    write(`${message}\\n`);\n  }\n}"}]}
{"messages":[{"role":"system","content":"You are an expert programmer. Write clean, working code."},{"role":"user","content":"## useStdout Hook\n\nThe useStdout hook provides access to the stdout stream and a write method for printing strings above Ink's main output area without disrupting the UI rendering. It returns an object containing the stdout stream and the write function. This is particularly useful for logging status updates or informational messages in CLI apps.\n\n```typescript\nimport {useStdout} from 'ink';\nconst {write} = useStdout();\nwrite('Hello from stdout\\n');\n\nimport React, {useEffect} from 'react';\nimport {useStdout} from 'ink';\nconst Demo = () => {\n  const {write} = useStdout();\n  useEffect(() => write('Logged on mount\\n'), []);\n  return null;\n};\n```\n\n---\n\nWrite code to solve this task:\n\nWrite a function conditionalLog(msg, condition) that only logs if condition is true, using useStdout.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nlet captured;\nconst mockWrite = (text) => { captured = text; };\nglobalThis.useStdout = () => ({ write: mockWrite });\n\nfunctionUnderTest('test', true);\nassert.strictEqual(captured, 'test\\n');\n\nfunctionUnderTest('no', false);\nassert.strictEqual(captured, 'test\\n');\n```\n\nReturn ONLY the code, no explanations."},{"role":"assistant","content":"function functionUnderTest(msg, condition) {\n  if (condition) {\n    const { write } = useStdout();\n    write(`${msg}\\n`);\n  }\n}"}]}
{"messages":[{"role":"system","content":"You are an expert programmer. Write clean, working code."},{"role":"user","content":"## useStderr Hook\n\nSimilar to useStdout, the useStderr hook exposes the stderr stream and a write method for error logging. Output appears above the Ink UI on stderr. It separates error messages from standard output effectively.\n\n```typescript\nimport {useStderr} from 'ink';\nconst {write} = useStderr();\nwrite('Error message\\n');\n\nimport React, {useEffect} from 'react';\nimport {useStderr} from 'ink';\nconst ErrorDemo = () => {\n  const {write} = useStderr();\n  useEffect(() => write('Error on mount\\n'), []);\n  return null;\n};\n```\n\n---\n\nWrite code to solve this task:\n\nWrite a function logError(errMsg) that uses useStderr to write the error message.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nlet captured;\nconst mockWrite = (text) => { captured = text; };\nglobalThis.useStderr = () => ({ write: mockWrite });\n\nfunctionUnderTest('Error occurred');\nassert.strictEqual(captured, 'Error occurred\\n');\n```\n\nReturn ONLY the code, no explanations."},{"role":"assistant","content":"export function functionUnderTest(errMsg) {\n  const {write} = useStderr();\n  write(`${errMsg}\\n`);\n}"}]}
{"messages":[{"role":"system","content":"You are an expert programmer. Write clean, working code."},{"role":"user","content":"## useStderr Hook\n\nSimilar to useStdout, the useStderr hook exposes the stderr stream and a write method for error logging. Output appears above the Ink UI on stderr. It separates error messages from standard output effectively.\n\n```typescript\nimport {useStderr} from 'ink';\nconst {write} = useStderr();\nwrite('Error message\\n');\n\nimport React, {useEffect} from 'react';\nimport {useStderr} from 'ink';\nconst ErrorDemo = () => {\n  const {write} = useStderr();\n  useEffect(() => write('Error on mount\\n'), []);\n  return null;\n};\n```\n\n---\n\nWrite code to solve this task:\n\nWrite a function logErrors(errors) that logs each error in the array to stderr.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nlet captured = [];\nconst mockWrite = (text) => { captured.push(text); };\nglobalThis.useStderr = () => ({ write: mockWrite });\n\nfunctionUnderTest(['err1', 'err2']);\nassert.deepStrictEqual(captured, ['err1\\n', 'err2\\n']);\n```\n\nReturn ONLY the code, no explanations."},{"role":"assistant","content":"function functionUnderTest(errors) {\n  const {write} = useStderr();\n  for (const error of errors) {\n    write(`${error}\\n`);\n  }\n}"}]}
{"messages":[{"role":"system","content":"You are an expert programmer. Write clean, working code."},{"role":"user","content":"## useStdin Hook\n\nThe useStdin hook gives access to the stdin stream, setRawMode function, and isRawModeSupported boolean. It enables raw input mode for capturing unprocessed keyboard data. Always clean up by disabling raw mode.\n\n```typescript\nimport {useStdin} from 'ink';\nconst {stdin, setRawMode, isRawModeSupported} = useStdin();\n\nimport React, {useEffect} from 'react';\nimport {useStdin} from 'ink';\nfunction Demo() {\n  const {setRawMode, isRawModeSupported} = useStdin();\n  useEffect(() => {\n    if (isRawModeSupported) setRawMode(true);\n  }, []);\n}\n```\n\n---\n\nWrite code to solve this task:\n\nWrite a function getStdinRawMode() that calls setRawMode(true) if supported using useStdin.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nlet setRawModeCalled = false;\nglobalThis.useStdin = () => ({ setRawMode: (b) => { setRawModeCalled = b; }, isRawModeSupported: true });\n\nfunctionUnderTest();\nassert.strictEqual(setRawModeCalled, true);\n```\n\nReturn ONLY the code, no explanations."},{"role":"assistant","content":"function functionUnderTest() {\n\tconst {setRawMode, isRawModeSupported} = useStdin();\n\tif (isRawModeSupported) setRawMode(true);\n}"}]}
{"messages":[{"role":"system","content":"You are an expert programmer. Write clean, working code."},{"role":"user","content":"## useStdin Hook\n\nThe useStdin hook gives access to the stdin stream, setRawMode function, and isRawModeSupported boolean. It enables raw input mode for capturing unprocessed keyboard data. Always clean up by disabling raw mode.\n\n```typescript\nimport {useStdin} from 'ink';\nconst {stdin, setRawMode, isRawModeSupported} = useStdin();\n\nimport React, {useEffect} from 'react';\nimport {useStdin} from 'ink';\nfunction Demo() {\n  const {setRawMode, isRawModeSupported} = useStdin();\n  useEffect(() => {\n    if (isRawModeSupported) setRawMode(true);\n  }, []);\n}\n```\n\n---\n\nWrite code to solve this task:\n\nWrite a function checkRawModeSupported() that returns isRawModeSupported from useStdin.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nglobalThis.useStdin = () => ({ isRawModeSupported: true });\nassert.strictEqual(functionUnderTest(), true);\n\nglobalThis.useStdin = () => ({ isRawModeSupported: false });\nassert.strictEqual(functionUnderTest(), false);\n```\n\nReturn ONLY the code, no explanations."},{"role":"assistant","content":"export function functionUnderTest() {\n\tconst {isRawModeSupported} = useStdin();\n\treturn isRawModeSupported;\n}"}]}
{"messages":[{"role":"system","content":"You are an expert programmer. Write clean, working code."},{"role":"user","content":"## useStdin Hook\n\nThe useStdin hook gives access to the stdin stream, setRawMode function, and isRawModeSupported boolean. It enables raw input mode for capturing unprocessed keyboard data. Always clean up by disabling raw mode.\n\n```typescript\nimport {useStdin} from 'ink';\nconst {stdin, setRawMode, isRawModeSupported} = useStdin();\n\nimport React, {useEffect} from 'react';\nimport {useStdin} from 'ink';\nfunction Demo() {\n  const {setRawMode, isRawModeSupported} = useStdin();\n  useEffect(() => {\n    if (isRawModeSupported) setRawMode(true);\n  }, []);\n}\n```\n\n---\n\nWrite code to solve this task:\n\nWrite a function enableRawMode() that enables raw mode only if supported and returns the stdin stream.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nlet called;\nglobalThis.useStdin = () => ({ setRawMode: (b) => { called = b; }, isRawModeSupported: true, stdin: {} });\nconst result = functionUnderTest();\nassert.strictEqual(called, true);\nassert.deepStrictEqual(result, {});\n```\n\nReturn ONLY the code, no explanations."},{"role":"assistant","content":"function functionUnderTest() {\n\tconst {stdin, setRawMode, isRawModeSupported} = useStdin();\n\tif (isRawModeSupported) setRawMode(true);\n\treturn stdin;\n}"}]}
{"messages":[{"role":"system","content":"You are an expert programmer. Write clean, working code."},{"role":"user","content":"## Raw Mode Input Handling\n\nIn raw mode via useStdin, listen to stdin 'data' events to process raw key bytes. Convert data Buffer to string or hex for key identification. Handle cleanup in useEffect return to prevent input issues.\n\n```typescript\nconst {stdin} = useStdin();\nstdin.on('data', (data) => {\n  console.log(Buffer.from(data).toString('hex'));\n});\n\nuseEffect(() => {\n  const handler = (data) => { /* handle */ };\n  stdin.on('data', handler);\n  return () => stdin.removeListener('data', handler);\n}, [stdin]);\n```\n\n---\n\nWrite code to solve this task:\n\nWrite a function setupKeyHandler(callback) that adds a 'data' listener to stdin in raw mode.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nlet listeners = [], setRawCalled;\nconst mockStdin = { on: (ev, cb) => { if (ev === 'data') listeners.push(cb); } };\nglobalThis.useStdin = () => ({ stdin: mockStdin, setRawMode: (b) => setRawCalled = b, isRawModeSupported: true });\n\nfunctionUnderTest(() => {});\nassert.strictEqual(setRawCalled, true);\nassert.strictEqual(listeners.length, 1);\n```\n\nReturn ONLY the code, no explanations."},{"role":"assistant","content":"function functionUnderTest(callback) {\n  const { stdin, setRawMode } = useStdin();\n  setRawMode(true);\n  stdin.on('data', callback);\n  return () => stdin.removeListener('data', callback);\n}"}]}
{"messages":[{"role":"system","content":"You are an expert programmer. Write clean, working code."},{"role":"user","content":"## Raw Mode Input Handling\n\nIn raw mode via useStdin, listen to stdin 'data' events to process raw key bytes. Convert data Buffer to string or hex for key identification. Handle cleanup in useEffect return to prevent input issues.\n\n```typescript\nconst {stdin} = useStdin();\nstdin.on('data', (data) => {\n  console.log(Buffer.from(data).toString('hex'));\n});\n\nuseEffect(() => {\n  const handler = (data) => { /* handle */ };\n  stdin.on('data', handler);\n  return () => stdin.removeListener('data', handler);\n}, [stdin]);\n```\n\n---\n\nWrite code to solve this task:\n\nWrite a function processKeyHex(dataBuffer) that logs the hex string of the buffer data.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nlet captured;\nconst mockWrite = (text) => captured = text;\nglobalThis.useStdout = () => ({ write: mockWrite });\n\nglobalThis.Buffer = class { static from(data) { return { toString: () => 'deadbeef' }; } };\n\nfunctionUnderTest(Buffer.from('deadbeef'));\nassert.strictEqual(captured, 'deadbeef\\n');\n```\n\nReturn ONLY the code, no explanations."},{"role":"assistant","content":"function functionUnderTest(dataBuffer) {\n  useStdout().write(dataBuffer.toString('hex') + '\\n');\n}"}]}
{"messages":[{"role":"system","content":"You are an expert programmer. Write clean, working code."},{"role":"user","content":"## Raw Mode Input Handling\n\nIn raw mode via useStdin, listen to stdin 'data' events to process raw key bytes. Convert data Buffer to string or hex for key identification. Handle cleanup in useEffect return to prevent input issues.\n\n```typescript\nconst {stdin} = useStdin();\nstdin.on('data', (data) => {\n  console.log(Buffer.from(data).toString('hex'));\n});\n\nuseEffect(() => {\n  const handler = (data) => { /* handle */ };\n  stdin.on('data', handler);\n  return () => stdin.removeListener('data', handler);\n}, [stdin]);\n```\n\n---\n\nWrite code to solve this task:\n\nWrite a function safeKeyListener() that adds listener, enables raw mode if supported, and cleans up on unmount simulation.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nlet added = 0, removed = 0, rawEnabled = false;\nconst mockStdin = { on: (_, cb) => added++, removeListener: () => removed++ };\nglobalThis.useStdin = () => ({ stdin: mockStdin, setRawMode: (b) => { rawEnabled = b; }, isRawModeSupported: true });\n\nfunctionUnderTest();\nassert.strictEqual(added, 1);\n// Simulate cleanup\n// assume return cleanup func or something, but for simple call twice? Wait adjust.\nassert.strictEqual(rawEnabled, true);\n```\n\nReturn ONLY the code, no explanations."},{"role":"assistant","content":"export function functionUnderTest() {\n  const { stdin, setRawMode, isRawModeSupported } = useStdin();\n  if (isRawModeSupported) {\n    setRawMode(true);\n  }\n  const onData = (data) => {\n    console.log(Buffer.from(data).toString('hex'));\n  };\n  stdin.on('data', onData);\n  return () => {\n    stdin.removeListener('data', onData);\n    if (isRawModeSupported) {\n      setRawMode(false);\n    }\n  };\n}"}]}
{"messages":[{"role":"system","content":"You are an expert programmer. Write clean, working code."},{"role":"user","content":"## Preserving Output with Stream Writes\n\nBoth useStdout.write and useStderr.write append raw strings to their respective streams above the Ink frame. Unlike Static, they only accept strings, not JSX. Output persists across frames like static content.\n\n```typescript\nconst {write} = useStdout();\nwrite('Persistent log\\n');\n\nconst {write} = useStderr();\nconst timer = setInterval(() => write(`Log ${Date.now()}\\n`), 1000);\n```\n\n---\n\nWrite code to solve this task:\n\nWrite a function persistentLog(msg) that uses useStdout.write to log persistently.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nlet captured;\nconst mockWrite = (text) => { captured = text; };\nglobalThis.useStdout = () => ({ write: mockWrite });\n\nfunctionUnderTest('persistent');\nassert.strictEqual(captured, 'persistent\\n');\n```\n\nReturn ONLY the code, no explanations."},{"role":"assistant","content":"function functionUnderTest(msg) {\n  const {write} = useStdout();\n  write(`${msg}\\n`);\n}"}]}
{"messages":[{"role":"system","content":"You are an expert programmer. Write clean, working code."},{"role":"user","content":"## Preserving Output with Stream Writes\n\nBoth useStdout.write and useStderr.write append raw strings to their respective streams above the Ink frame. Unlike Static, they only accept strings, not JSX. Output persists across frames like static content.\n\n```typescript\nconst {write} = useStdout();\nwrite('Persistent log\\n');\n\nconst {write} = useStderr();\nconst timer = setInterval(() => write(`Log ${Date.now()}\\n`), 1000);\n```\n\n---\n\nWrite code to solve this task:\n\nWrite a function intervalLogger(intervalMs, msg) that sets interval to log msg using useStdout.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nlet captured = [], intervalId;\nconst mockWrite = (text) => captured.push(text);\nglobalThis.useStdout = () => ({ write: mockWrite });\nglobalThis.setInterval = (cb) => intervalId = setTimeout(cb, 0);\n\nfunctionUnderTest(1, 'interval');\n// Simulate tick\nif (intervalId) clearInterval(intervalId); // but check captured\nassert.strictEqual(captured[0], 'interval\\n');\n```\n\nReturn ONLY the code, no explanations."},{"role":"assistant","content":"function functionUnderTest(intervalMs, msg) {\n  const { write } = useStdout();\n  const log = () => write(`${msg}\\n`);\n  log();\n  return setInterval(log, intervalMs);\n}"}]}
{"messages":[{"role":"system","content":"You are an expert programmer. Write clean, working code."},{"role":"user","content":"## Preserving Output with Stream Writes\n\nBoth useStdout.write and useStderr.write append raw strings to their respective streams above the Ink frame. Unlike Static, they only accept strings, not JSX. Output persists across frames like static content.\n\n```typescript\nconst {write} = useStdout();\nwrite('Persistent log\\n');\n\nconst {write} = useStderr();\nconst timer = setInterval(() => write(`Log ${Date.now()}\\n`), 1000);\n```\n\n---\n\nWrite code to solve this task:\n\nWrite a function logToStream(streamType, msg) that writes to useStdout or useStderr based on streamType.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nlet stdoutCaptured, stderrCaptured;\nglobalThis.useStdout = () => ({ write: (t) => stdoutCaptured = t });\nglobalThis.useStderr = () => ({ write: (t) => stderrCaptured = t });\n\nfunctionUnderTest('stdout', 'out msg');\nassert.strictEqual(stdoutCaptured, 'out msg\\n');\nfunctionUnderTest('stderr', 'err msg');\nassert.strictEqual(stderrCaptured, 'err msg\\n');\n```\n\nReturn ONLY the code, no explanations."},{"role":"assistant","content":"function functionUnderTest(streamType, msg) {\n  if (streamType === 'stdout') {\n    const { write } = useStdout();\n    write(`${msg}\\n`);\n  } else {\n    const { write } = useStderr();\n    write(`${msg}\\n`);\n  }\n}"}]}
{"messages":[{"role":"system","content":"You are an expert programmer. Write clean, working code."},{"role":"user","content":"## ARIA Accessibility in Ink Components\n\nInk's Box and Text components support ARIA attributes like aria-role, aria-state, and aria-label for screen reader compatibility. Use aria-state objects for dynamic states like checked or disabled. Pair with useIsScreenReaderEnabled for conditional verbose output.\n\n```typescript\n<Box aria-role=\"checkbox\" aria-state={{checked: true}}>\n  <Text>Accept terms</Text>\n</Box>\n\n<Box aria-role=\"button\" aria-label=\"Submit\">\n  <Text>Submit</Text>\n</Box>\n```\n\n---\n\nWrite code to solve this task:\n\nWrite a function checkboxJsx(checked, label) that returns Box with aria-role='checkbox' and aria-state={{checked}} containing Text label.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nlet capturedProps;\nglobalThis.Box = (props) => { capturedProps = props; return null; };\nglobalThis.Text = () => null;\n\nconst result = functionUnderTest(true, 'Terms');\nassert.strictEqual(capturedProps['aria-role'], 'checkbox');\nassert.deepStrictEqual(capturedProps['aria-state'], {checked: true});\n```\n\nReturn ONLY the code, no explanations."},{"role":"assistant","content":"function functionUnderTest(checked, label) {\n  return Box(\n    {\n      'aria-role': 'checkbox',\n      'aria-state': { checked }\n    },\n    Text(label)\n  );\n}"}]}
{"messages":[{"role":"system","content":"You are an expert programmer. Write clean, working code."},{"role":"user","content":"## ARIA Accessibility in Ink Components\n\nInk's Box and Text components support ARIA attributes like aria-role, aria-state, and aria-label for screen reader compatibility. Use aria-state objects for dynamic states like checked or disabled. Pair with useIsScreenReaderEnabled for conditional verbose output.\n\n```typescript\n<Box aria-role=\"checkbox\" aria-state={{checked: true}}>\n  <Text>Accept terms</Text>\n</Box>\n\n<Box aria-role=\"button\" aria-label=\"Submit\">\n  <Text>Submit</Text>\n</Box>\n```\n\n---\n\nWrite code to solve this task:\n\nWrite a function conditionalAria(state) that adds aria-state only if state provided for checkbox.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nlet captured;\nglobalThis.Box = (props) => { captured = props; };\nfunctionUnderTest({checked: true});\nassert.deepStrictEqual(captured['aria-state'], {checked: true});\n\nfunctionUnderTest();\ndelete captured['aria-state']; // check absent\n```\n\nReturn ONLY the code, no explanations."},{"role":"assistant","content":"function functionUnderTest(state) {\n  return Box({\n    'aria-role': 'checkbox',\n    ...(state ? { 'aria-state': state } : {})\n  });\n}"}]}
{"messages":[{"role":"system","content":"You are an expert programmer. Write clean, working code."},{"role":"user","content":"## useStdin Hook\n\nThe useStdin hook gives access to the stdin stream, setRawMode function, and isRawModeSupported boolean. It enables raw input mode for capturing unprocessed keyboard data. Always clean up by disabling raw mode.\n\n```typescript\nimport {useStdin} from 'ink';\nconst {stdin, setRawMode, isRawModeSupported} = useStdin();\n\nimport React, {useEffect} from 'react';\nimport {useStdin} from 'ink';\nfunction Demo() {\n  const {setRawMode, isRawModeSupported} = useStdin();\n  useEffect(() => {\n    if (isRawModeSupported) setRawMode(true);\n  }, []);\n}\n```\n\n---\n\nWrite code to solve this task:\n\nWrite a function disableRawMode() that calls setRawMode(false) unconditionally.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nlet modeSet;\nglobalThis.useStdin = () => ({ setRawMode: (b) => modeSet = b });\nfunctionUnderTest();\nassert.strictEqual(modeSet, false);\n```\n\nReturn ONLY the code, no explanations."},{"role":"assistant","content":"function functionUnderTest() {\n  const { setRawMode } = useStdin();\n  setRawMode(false);\n}"}]}
{"messages":[{"role":"system","content":"You are an expert programmer. Write clean, working code."},{"role":"user","content":"## Raw Mode Input Handling\n\nIn raw mode via useStdin, listen to stdin 'data' events to process raw key bytes. Convert data Buffer to string or hex for key identification. Handle cleanup in useEffect return to prevent input issues.\n\n```typescript\nconst {stdin} = useStdin();\nstdin.on('data', (data) => {\n  console.log(Buffer.from(data).toString('hex'));\n});\n\nuseEffect(() => {\n  const handler = (data) => { /* handle */ };\n  stdin.on('data', handler);\n  return () => stdin.removeListener('data', handler);\n}, [stdin]);\n```\n\n---\n\nWrite code to solve this task:\n\nWrite a function hexKeyProcessor(keyData) that returns hex of keyData buffer.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nglobalThis.Buffer = class Buffer { static from(b) { return { toString: () => '6162' }; } };\nassert.strictEqual(functionUnderTest(new Uint8Array([97,98])), '6162');\n```\n\nReturn ONLY the code, no explanations."},{"role":"assistant","content":"function functionUnderTest(keyData) {\n  return Buffer.from(keyData).toString('hex');\n}"}]}
{"messages":[{"role":"system","content":"You are an expert programmer. Write clean, working code."},{"role":"user","content":"## Preserving Output with Stream Writes\n\nBoth useStdout.write and useStderr.write append raw strings to their respective streams above the Ink frame. Unlike Static, they only accept strings, not JSX. Output persists across frames like static content.\n\n```typescript\nconst {write} = useStdout();\nwrite('Persistent log\\n');\n\nconst {write} = useStderr();\nconst timer = setInterval(() => write(`Log ${Date.now()}\\n`), 1000);\n```\n\n---\n\nWrite code to solve this task:\n\nWrite a function heartbeatLog() that writes timestamped heartbeat every 2000ms sim.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nlet captured = [], calls = 0;\nconst mockWrite = (text) => { captured.push(text); calls++; };\nglobalThis.useStdout = () => ({ write: mockWrite });\nglobalThis.setInterval = (cb, ms) => cb();\nfunctionUnderTest();\nassert.strictEqual(calls, 1);\nassert.ok(captured[0].includes('Heartbeat'));\n```\n\nReturn ONLY the code, no explanations."},{"role":"assistant","content":"function functionUnderTest() {\n  const {write} = useStdout();\n  const timer = setInterval(() => write(`Heartbeat ${Date.now()}\\n`), 2000);\n}"}]}
{"messages":[{"role":"system","content":"You are an expert programmer. Write clean, working code."},{"role":"user","content":"## useStdout Hook\n\nThe useStdout hook provides access to the stdout stream and a write method for printing strings above Ink's main output area without disrupting the UI rendering. It returns an object containing the stdout stream and the write function. This is particularly useful for logging status updates or informational messages in CLI apps.\n\n```typescript\nimport {useStdout} from 'ink';\nconst {write} = useStdout();\nwrite('Hello from stdout\\n');\n\nimport React, {useEffect} from 'react';\nimport {useStdout} from 'ink';\nconst Demo = () => {\n  const {write} = useStdout();\n  useEffect(() => write('Logged on mount\\n'), []);\n  return null;\n};\n```\n\n---\n\nWrite code to solve this task:\n\nWrite a function accessStdout() that returns the stdout stream from useStdout.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nconst mockStream = {};\nglobalThis.useStdout = () => ({ stdout: mockStream });\nconst result = functionUnderTest();\nassert.strictEqual(result, mockStream);\n```\n\nReturn ONLY the code, no explanations."},{"role":"assistant","content":"function functionUnderTest() {\n  const { stdout } = useStdout();\n  return stdout;\n}"}]}
{"messages":[{"role":"system","content":"You are an expert programmer. Write clean, working code."},{"role":"user","content":"## useStderr Hook\n\nSimilar to useStdout, the useStderr hook exposes the stderr stream and a write method for error logging. Output appears above the Ink UI on stderr. It separates error messages from standard output effectively.\n\n```typescript\nimport {useStderr} from 'ink';\nconst {write} = useStderr();\nwrite('Error message\\n');\n\nimport React, {useEffect} from 'react';\nimport {useStderr} from 'ink';\nconst ErrorDemo = () => {\n  const {write} = useStderr();\n  useEffect(() => write('Error on mount\\n'), []);\n  return null;\n};\n```\n\n---\n\nWrite code to solve this task:\n\nWrite a function accessStderr() that returns stderr stream.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nconst mockStream = {};\nglobalThis.useStderr = () => ({ stderr: mockStream });\nassert.strictEqual(functionUnderTest(), mockStream);\n```\n\nReturn ONLY the code, no explanations."},{"role":"assistant","content":"function functionUnderTest() {\n  return useStderr().stderr;\n}"}]}