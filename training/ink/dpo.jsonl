{"prompt":"Write code to solve this task:\n\nWrite a function logMessage(msg) that uses useStdout to write the given message followed by a newline.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nlet captured;\nconst mockWrite = (text) => { captured = text; };\nglobalThis.useStdout = () => ({ write: mockWrite });\n\nfunctionUnderTest('Hello World');\n\nassert.strictEqual(captured, 'Hello World\\n');\n```\n\nReturn ONLY the code, no explanations.","chosen":"function functionUnderTest(msg) {\n\tconst { write } = useStdout();\n\twrite(`${msg}\\n`);\n}","rejected":"async function logMessage(msg) {\n  await useStdout(msg + '\\n');\n}"}
{"prompt":"Write code to solve this task:\n\nWrite a function logMultiple(messages) that logs each message in the array using useStdout.write.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nlet captured = [];\nconst mockWrite = (text) => { captured.push(text); };\nglobalThis.useStdout = () => ({ write: mockWrite });\n\nfunctionUnderTest(['msg1', 'msg2']);\n\nassert.deepStrictEqual(captured, ['msg1\\n', 'msg2\\n']);\n```\n\nReturn ONLY the code, no explanations.","chosen":"function functionUnderTest(messages) {\n  const {write} = useStdout();\n  for (const message of messages) {\n    write(`${message}\\n`);\n  }\n}","rejected":"export async function logMultiple(messages) {\n  for (const message of messages) {\n    await useStdout.write(message + '\\n');\n  }\n}"}
{"prompt":"Write code to solve this task:\n\nWrite a function conditionalLog(msg, condition) that only logs if condition is true, using useStdout.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nlet captured;\nconst mockWrite = (text) => { captured = text; };\nglobalThis.useStdout = () => ({ write: mockWrite });\n\nfunctionUnderTest('test', true);\nassert.strictEqual(captured, 'test\\n');\n\nfunctionUnderTest('no', false);\nassert.strictEqual(captured, 'test\\n');\n```\n\nReturn ONLY the code, no explanations.","chosen":"function functionUnderTest(msg, condition) {\n  if (condition) {\n    const { write } = useStdout();\n    write(`${msg}\\n`);\n  }\n}","rejected":"export async function conditionalLog(msg, condition) {\n  if (condition) {\n    await useStdout(msg);\n  }\n}"}
{"prompt":"Write code to solve this task:\n\nWrite a function logError(errMsg) that uses useStderr to write the error message.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nlet captured;\nconst mockWrite = (text) => { captured = text; };\nglobalThis.useStderr = () => ({ write: mockWrite });\n\nfunctionUnderTest('Error occurred');\nassert.strictEqual(captured, 'Error occurred\\n');\n```\n\nReturn ONLY the code, no explanations.","chosen":"export function functionUnderTest(errMsg) {\n  const {write} = useStderr();\n  write(`${errMsg}\\n`);\n}","rejected":"export function logError(errMsg) {\n  useStderr(errMsg);\n}"}
{"prompt":"Write code to solve this task:\n\nWrite a function logErrors(errors) that logs each error in the array to stderr.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nlet captured = [];\nconst mockWrite = (text) => { captured.push(text); };\nglobalThis.useStderr = () => ({ write: mockWrite });\n\nfunctionUnderTest(['err1', 'err2']);\nassert.deepStrictEqual(captured, ['err1\\n', 'err2\\n']);\n```\n\nReturn ONLY the code, no explanations.","chosen":"function functionUnderTest(errors) {\n  const {write} = useStderr();\n  for (const error of errors) {\n    write(`${error}\\n`);\n  }\n}","rejected":"export function logErrors(errors) {\n  errors.forEach(console.error);\n}"}
{"prompt":"Write code to solve this task:\n\nWrite a function getStdinRawMode() that calls setRawMode(true) if supported using useStdin.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nlet setRawModeCalled = false;\nglobalThis.useStdin = () => ({ setRawMode: (b) => { setRawModeCalled = b; }, isRawModeSupported: true });\n\nfunctionUnderTest();\nassert.strictEqual(setRawModeCalled, true);\n```\n\nReturn ONLY the code, no explanations.","chosen":"function functionUnderTest() {\n\tconst {setRawMode, isRawModeSupported} = useStdin();\n\tif (isRawModeSupported) setRawMode(true);\n}","rejected":"export async function getStdinRawMode() {\n  if (process.stdin.isTTY) {\n    process.stdin.setRawMode(true);\n    return true;\n  }\n  return false;\n}"}
{"prompt":"Write code to solve this task:\n\nWrite a function checkRawModeSupported() that returns isRawModeSupported from useStdin.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nglobalThis.useStdin = () => ({ isRawModeSupported: true });\nassert.strictEqual(functionUnderTest(), true);\n\nglobalThis.useStdin = () => ({ isRawModeSupported: false });\nassert.strictEqual(functionUnderTest(), false);\n```\n\nReturn ONLY the code, no explanations.","chosen":"export function functionUnderTest() {\n\tconst {isRawModeSupported} = useStdin();\n\treturn isRawModeSupported;\n}","rejected":"export function checkRawModeSupported() {\n\tif (!process.stdin.isTTY) {\n\t\treturn false;\n\t}\n\n\tif (process.platform !== 'win32') {\n\t\treturn true;\n\t}\n\n\treturn Boolean(\n\t\tprocess.env.WT_SESSION ||\n\t\tprocess.env.WT_PROFILE_ID ||\n\t\tprocess.env.TERM_PROGRAM === 'vscode' ||\n\t\tprocess.env.TERM_PROGRAM === 'Hyper' ||\n\t\tprocess.env.TERM_PROGRAM === 'iTerm.app' ||\n\t\tprocess.env.TERM_PROGRAM === 'WezTerm' ||\n\t\tprocess.env.CONEMU_TASK_NAME ||\n\t\tprocess.env.TERM === 'xterm' ||\n\t\tprocess.env.TERM === 'xterm-256color' ||\n\t\tprocess.env.TERM?.startsWith('screen')\n\t);\n}"}
{"prompt":"Write code to solve this task:\n\nWrite a function enableRawMode() that enables raw mode only if supported and returns the stdin stream.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nlet called;\nglobalThis.useStdin = () => ({ setRawMode: (b) => { called = b; }, isRawModeSupported: true, stdin: {} });\nconst result = functionUnderTest();\nassert.strictEqual(called, true);\nassert.deepStrictEqual(result, {});\n```\n\nReturn ONLY the code, no explanations.","chosen":"function functionUnderTest() {\n\tconst {stdin, setRawMode, isRawModeSupported} = useStdin();\n\tif (isRawModeSupported) setRawMode(true);\n\treturn stdin;\n}","rejected":"export function enableRawMode() {\n  if (process.stdin.isTTY) {\n    process.stdin.setRawMode(true);\n  }\n  return process.stdin;\n}"}
{"prompt":"Write code to solve this task:\n\nWrite a function setupKeyHandler(callback) that adds a 'data' listener to stdin in raw mode.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nlet listeners = [], setRawCalled;\nconst mockStdin = { on: (ev, cb) => { if (ev === 'data') listeners.push(cb); } };\nglobalThis.useStdin = () => ({ stdin: mockStdin, setRawMode: (b) => setRawCalled = b, isRawModeSupported: true });\n\nfunctionUnderTest(() => {});\nassert.strictEqual(setRawCalled, true);\nassert.strictEqual(listeners.length, 1);\n```\n\nReturn ONLY the code, no explanations.","chosen":"function functionUnderTest(callback) {\n  const { stdin, setRawMode } = useStdin();\n  setRawMode(true);\n  stdin.on('data', callback);\n  return () => stdin.removeListener('data', callback);\n}","rejected":"export function setupKeyHandler(callback) {\n  const stdin = process.stdin;\n  if (stdin.isTTY) {\n    stdin.setRawMode(true);\n  }\n  stdin.resume();\n  stdin.on('data', callback);\n}"}
{"prompt":"Write code to solve this task:\n\nWrite a function processKeyHex(dataBuffer) that logs the hex string of the buffer data.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nlet captured;\nconst mockWrite = (text) => captured = text;\nglobalThis.useStdout = () => ({ write: mockWrite });\n\nglobalThis.Buffer = class { static from(data) { return { toString: () => 'deadbeef' }; } };\n\nfunctionUnderTest(Buffer.from('deadbeef'));\nassert.strictEqual(captured, 'deadbeef\\n');\n```\n\nReturn ONLY the code, no explanations.","chosen":"function functionUnderTest(dataBuffer) {\n  useStdout().write(dataBuffer.toString('hex') + '\\n');\n}","rejected":"export async function processKeyHex(dataBuffer) {\n  console.log(dataBuffer.toString('hex'));\n}"}
{"prompt":"Write code to solve this task:\n\nWrite a function safeKeyListener() that adds listener, enables raw mode if supported, and cleans up on unmount simulation.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nlet added = 0, removed = 0, rawEnabled = false;\nconst mockStdin = { on: (_, cb) => added++, removeListener: () => removed++ };\nglobalThis.useStdin = () => ({ stdin: mockStdin, setRawMode: (b) => { rawEnabled = b; }, isRawModeSupported: true });\n\nfunctionUnderTest();\nassert.strictEqual(added, 1);\n// Simulate cleanup\n// assume return cleanup func or something, but for simple call twice? Wait adjust.\nassert.strictEqual(rawEnabled, true);\n```\n\nReturn ONLY the code, no explanations.","chosen":"export function functionUnderTest() {\n  const { stdin, setRawMode, isRawModeSupported } = useStdin();\n  if (isRawModeSupported) {\n    setRawMode(true);\n  }\n  const onData = (data) => {\n    console.log(Buffer.from(data).toString('hex'));\n  };\n  stdin.on('data', onData);\n  return () => {\n    stdin.removeListener('data', onData);\n    if (isRawModeSupported) {\n      setRawMode(false);\n    }\n  };\n}","rejected":"export function safeKeyListener() {\n  const queue = [];\n  let resolvePending = null;\n  let closed = false;\n  const listener = (key) => {\n    if (closed) return;\n    if (resolvePending) {\n      const resolve = resolvePending;\n      resolvePending = null;\n      resolve(key);\n      return;\n    }\n    queue.push(key);\n  };\n  if (process.stdin.isTTY) {\n    process.stdin.setRawMode(true);\n  }\n  process.stdin.resume();\n  process.stdin.on('data', listener);\n  const nextKey = async () => {\n    if (closed) {\n      throw new Error('KeyListener destroyed');\n    }\n    if (queue.length > 0) {\n      return queue.shift();\n    }\n    return new Promise((resolve) => {\n      resolvePending = resolve;\n    });\n  };\n  const destroy = () => {\n    closed = true;\n    if (resolvePending) {\n      resolvePending(new Error('KeyListener destroyed'));\n      resolvePending = null;\n    }\n    process.stdin.removeListener('data', listener);\n    if (process.stdin.isTTY) {\n      process.stdin.setRawMode(false);\n    }\n    process.stdin.pause();\n  };\n  return { nextKey, destroy };\n}"}
{"prompt":"Write code to solve this task:\n\nWrite a function persistentLog(msg) that uses useStdout.write to log persistently.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nlet captured;\nconst mockWrite = (text) => { captured = text; };\nglobalThis.useStdout = () => ({ write: mockWrite });\n\nfunctionUnderTest('persistent');\nassert.strictEqual(captured, 'persistent\\n');\n```\n\nReturn ONLY the code, no explanations.","chosen":"function functionUnderTest(msg) {\n  const {write} = useStdout();\n  write(`${msg}\\n`);\n}","rejected":"export async function persistentLog(msg) {\n  await useStdout.write(`${msg}\\n`);\n}"}
{"prompt":"Write code to solve this task:\n\nWrite a function intervalLogger(intervalMs, msg) that sets interval to log msg using useStdout.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nlet captured = [], intervalId;\nconst mockWrite = (text) => captured.push(text);\nglobalThis.useStdout = () => ({ write: mockWrite });\nglobalThis.setInterval = (cb) => intervalId = setTimeout(cb, 0);\n\nfunctionUnderTest(1, 'interval');\n// Simulate tick\nif (intervalId) clearInterval(intervalId); // but check captured\nassert.strictEqual(captured[0], 'interval\\n');\n```\n\nReturn ONLY the code, no explanations.","chosen":"function functionUnderTest(intervalMs, msg) {\n  const { write } = useStdout();\n  const log = () => write(`${msg}\\n`);\n  log();\n  return setInterval(log, intervalMs);\n}","rejected":"export function intervalLogger(intervalMs, msg) {\n  return setInterval(() => useStdout(msg), intervalMs);\n}"}
{"prompt":"Write code to solve this task:\n\nWrite a function logToStream(streamType, msg) that writes to useStdout or useStderr based on streamType.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nlet stdoutCaptured, stderrCaptured;\nglobalThis.useStdout = () => ({ write: (t) => stdoutCaptured = t });\nglobalThis.useStderr = () => ({ write: (t) => stderrCaptured = t });\n\nfunctionUnderTest('stdout', 'out msg');\nassert.strictEqual(stdoutCaptured, 'out msg\\n');\nfunctionUnderTest('stderr', 'err msg');\nassert.strictEqual(stderrCaptured, 'err msg\\n');\n```\n\nReturn ONLY the code, no explanations.","chosen":"function functionUnderTest(streamType, msg) {\n  if (streamType === 'stdout') {\n    const { write } = useStdout();\n    write(`${msg}\\n`);\n  } else {\n    const { write } = useStderr();\n    write(`${msg}\\n`);\n  }\n}","rejected":"export async function logToStream(streamType, msg) {\n  if (streamType === 'stdout') {\n    await useStdout(msg);\n  } else {\n    await useStderr(msg);\n  }\n}"}
{"prompt":"Write code to solve this task:\n\nWrite a function checkboxJsx(checked, label) that returns Box with aria-role='checkbox' and aria-state={{checked}} containing Text label.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nlet capturedProps;\nglobalThis.Box = (props) => { capturedProps = props; return null; };\nglobalThis.Text = () => null;\n\nconst result = functionUnderTest(true, 'Terms');\nassert.strictEqual(capturedProps['aria-role'], 'checkbox');\nassert.deepStrictEqual(capturedProps['aria-state'], {checked: true});\n```\n\nReturn ONLY the code, no explanations.","chosen":"function functionUnderTest(checked, label) {\n  return Box(\n    {\n      'aria-role': 'checkbox',\n      'aria-state': { checked }\n    },\n    Text(label)\n  );\n}","rejected":"export function checkboxJsx(checked, label) {\n  return (\n    <Box aria-role='checkbox' aria-state={{checked}}>\n      <Text>{label}</Text>\n    </Box>\n  );\n}"}
{"prompt":"Write code to solve this task:\n\nWrite a function conditionalAria(state) that adds aria-state only if state provided for checkbox.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nlet captured;\nglobalThis.Box = (props) => { captured = props; };\nfunctionUnderTest({checked: true});\nassert.deepStrictEqual(captured['aria-state'], {checked: true});\n\nfunctionUnderTest();\ndelete captured['aria-state']; // check absent\n```\n\nReturn ONLY the code, no explanations.","chosen":"function functionUnderTest(state) {\n  return Box({\n    'aria-role': 'checkbox',\n    ...(state ? { 'aria-state': state } : {})\n  });\n}","rejected":"export function conditionalAria(state) {\n  if (state === undefined) return '';\n  return `aria-state=\"${state}\"`;\n}"}
{"prompt":"Write code to solve this task:\n\nWrite a function disableRawMode() that calls setRawMode(false) unconditionally.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nlet modeSet;\nglobalThis.useStdin = () => ({ setRawMode: (b) => modeSet = b });\nfunctionUnderTest();\nassert.strictEqual(modeSet, false);\n```\n\nReturn ONLY the code, no explanations.","chosen":"function functionUnderTest() {\n  const { setRawMode } = useStdin();\n  setRawMode(false);\n}","rejected":"export function disableRawMode() {\n  setRawMode(false);\n}"}
{"prompt":"Write code to solve this task:\n\nWrite a function hexKeyProcessor(keyData) that returns hex of keyData buffer.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nglobalThis.Buffer = class Buffer { static from(b) { return { toString: () => '6162' }; } };\nassert.strictEqual(functionUnderTest(new Uint8Array([97,98])), '6162');\n```\n\nReturn ONLY the code, no explanations.","chosen":"function functionUnderTest(keyData) {\n  return Buffer.from(keyData).toString('hex');\n}","rejected":"export function hexKeyProcessor(keyData) {\n  return Buffer.from(keyData).toString('hex');\n}"}
{"prompt":"Write code to solve this task:\n\nWrite a function heartbeatLog() that writes timestamped heartbeat every 2000ms sim.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nlet captured = [], calls = 0;\nconst mockWrite = (text) => { captured.push(text); calls++; };\nglobalThis.useStdout = () => ({ write: mockWrite });\nglobalThis.setInterval = (cb, ms) => cb();\nfunctionUnderTest();\nassert.strictEqual(calls, 1);\nassert.ok(captured[0].includes('Heartbeat'));\n```\n\nReturn ONLY the code, no explanations.","chosen":"function functionUnderTest() {\n  const {write} = useStdout();\n  const timer = setInterval(() => write(`Heartbeat ${Date.now()}\\n`), 2000);\n}","rejected":"export async function heartbeatLog() {\n  while (true) {\n    console.log(`${new Date().toISOString()} Heartbeat`);\n    await new Promise((resolve) => setTimeout(resolve, 2000));\n  }\n}"}
{"prompt":"Write code to solve this task:\n\nWrite a function accessStdout() that returns the stdout stream from useStdout.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nconst mockStream = {};\nglobalThis.useStdout = () => ({ stdout: mockStream });\nconst result = functionUnderTest();\nassert.strictEqual(result, mockStream);\n```\n\nReturn ONLY the code, no explanations.","chosen":"function functionUnderTest() {\n  const { stdout } = useStdout();\n  return stdout;\n}","rejected":"export function accessStdout() {\n  const { stdout } = useStdout();\n  return stdout;\n}"}
{"prompt":"Write code to solve this task:\n\nWrite a function accessStderr() that returns stderr stream.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nconst mockStream = {};\nglobalThis.useStderr = () => ({ stderr: mockStream });\nassert.strictEqual(functionUnderTest(), mockStream);\n```\n\nReturn ONLY the code, no explanations.","chosen":"function functionUnderTest() {\n  return useStderr().stderr;\n}","rejected":"import { stderr } from 'node:process';\n\nexport function accessStderr() {\n  return stderr;\n}"}