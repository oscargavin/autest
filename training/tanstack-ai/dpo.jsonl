{"prompt":"Write code to solve this task:\n\nWrite a function to extract text content from message parts.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\ntest('extract text content from message parts', () => {\n  const message = {\n    parts: [\n      { type: 'text', content: 'Hello' },\n      { type: 'thinking', content: 'Thinking...' }\n    ]\n  };\n  const text = extractTextContent(message);\n  assert.strictEqual(text, 'Hello');\n});\n\nfunction extractTextContent(message) {\n  const textPart = message.parts.find(part => part.type === 'text');\n  return textPart ? textPart.content : '';\n}\n```\n\nReturn ONLY the code, no explanations.","chosen":"function getTextContent(message) {\n  return message.parts\n    .filter(part => part.type === 'text')\n    .map(part => part.content)\n    .join(' ');\n}","rejected":"export async function extractTextContent(messageParts) {\n  if (!Array.isArray(messageParts)) {\n    throw new Error('Input must be an array of message parts');\n  }\n\n  const textParts = messageParts\n    .filter(part => part.type === 'text' && typeof part.content === 'string')\n    .map(part => part.content.trim())\n    .filter(content => content.length > 0);\n\n  return textParts.join(' ');\n}"}
{"prompt":"Write code to solve this task:\n\nWrite a function to handle all message part types with custom formatting.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\ntest('handle all message part types with formatting', () => {\n  const message = {\n    parts: [\n      { type: 'text', content: 'Hello' },\n      { type: 'thinking', content: 'Thinking...' },\n      { type: 'tool_call', content: 'Calling tool' }\n    ]\n  };\n  const formatted = formatMessageParts(message);\n  assert.strictEqual(formatted.length, 3);\n  assert.strictEqual(formatted[0], 'Hello');\n  assert.strictEqual(formatted[1], 'Thinking: Thinking...');\n  assert.strictEqual(formatted[2], 'Tool: Calling tool');\n});\n\nfunction formatMessageParts(message) {\n  return message.parts.map(part => {\n    if (part.type === 'text') return part.content;\n    if (part.type === 'thinking') return `Thinking: ${part.content}`;\n    if (part.type === 'tool_call') return `Tool: ${part.content}`;\n    return '';\n  }).filter(Boolean);\n}\n```\n\nReturn ONLY the code, no explanations.","chosen":"export function formatMessageContent(message) {\n  return message.parts.map((part) => {\n    switch (part.type) {\n      case 'text':\n        return part.content;\n      case 'thinking':\n        return `Thinking: ${part.content}`;\n      case 'tool_call':\n        return `Tool: ${part.content}`;\n      default:\n        return '';\n    }\n  }).filter(Boolean);\n}","rejected":"export async function formatMessageParts(parts) {\n  if (!Array.isArray(parts)) {\n    throw new Error('Input must be an array of message parts');\n  }\n\n  const formattedParts = await Promise.all(parts.map(async (part) => {\n    if (!part || typeof part !== 'object') {\n      return '';\n    }\n\n    const { type, content } = part;\n\n    switch (type) {\n      case 'text':\n        return content || '';\n      case 'bold':\n        return content ? `**${content}**` : '';\n      case 'italic':\n        return content ? `*${content}*` : '';\n      case 'code':\n        return content ? `\\`${content}\\`` : '';\n      case 'link':\n        return content && part.url ? `[${content}](${part.url})` : content || '';\n      case 'image':\n        if (part.url) {\n          await new Promise(resolve => setTimeout(resolve, 100)); // Simulate async image processing\n          return `![${part.alt || 'image'}](${part.url})`;\n        }\n        return '';\n      default:\n        return content || '';\n    }\n  }));\n\n  return formattedParts.join('').trim();\n}"}