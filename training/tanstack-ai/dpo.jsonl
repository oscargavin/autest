{"prompt":"Write code to solve this task:\n\nCreate a basic useChat implementation that connects to an endpoint\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nlet capturedConnection;\nglobalThis.useChat = ({ connection }) => {\n  capturedConnection = connection;\n  return { messages: [], sendMessage: () => {}, isLoading: false };\n};\n\nglobalThis.fetchServerSentEvents = (endpoint) => ({ endpoint, type: 'sse' });\n\ntest('useChat connects to /api/chat endpoint', () => {\n  const { useChat, fetchServerSentEvents } = globalThis;\n  const chat = useChat({ connection: fetchServerSentEvents('/api/chat') });\n  \n  assert.strictEqual(capturedConnection.endpoint, '/api/chat');\n  assert.strictEqual(capturedConnection.type, 'sse');\n});\n\ntest('useChat returns required properties', () => {\n  const { useChat, fetchServerSentEvents } = globalThis;\n  const chat = useChat({ connection: fetchServerSentEvents('/api/chat') });\n  \n  assert.ok(Array.isArray(chat.messages));\n  assert.strictEqual(typeof chat.sendMessage, 'function');\n  assert.strictEqual(typeof chat.isLoading, 'boolean');\n});\n```\n\nReturn ONLY the code, no explanations.","chosen":"export function createChatHook() {\n  return useChat({\n    connection: fetchServerSentEvents(\"/api/chat\"),\n  });\n}","rejected":"export function createChatHook() {\n  return useChat(fetchServerSentEvents(\"/api/chat\"));\n}"}
{"prompt":"Write code to solve this task:\n\nConfigure useChat with lifecycle callbacks\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nlet capturedCallbacks = {};\nglobalThis.useChat = (config) => {\n  capturedCallbacks = {\n    onChunk: config.onChunk,\n    onFinish: config.onFinish,\n    onError: config.onError\n  };\n  return { messages: [] };\n};\n\ntest('useChat accepts onChunk callback', () => {\n  const onChunk = (chunk) => {};\n  globalThis.useChat({ connection: {}, onChunk });\n  \n  assert.strictEqual(capturedCallbacks.onChunk, onChunk);\n});\n\ntest('useChat accepts onFinish callback', () => {\n  const onFinish = (msg) => {};\n  globalThis.useChat({ connection: {}, onFinish });\n  \n  assert.strictEqual(capturedCallbacks.onFinish, onFinish);\n});\n\ntest('useChat accepts onError callback', () => {\n  const onError = (err) => {};\n  globalThis.useChat({ connection: {}, onError });\n  \n  assert.strictEqual(capturedCallbacks.onError, onError);\n});\n```\n\nReturn ONLY the code, no explanations.","chosen":"export function useChatWithCallbacks(url, onFinish, onError) {\n  return useChat({\n    connection: fetchServerSentEvents(url),\n    onFinish: onFinish,\n    onError: onError,\n  });\n}","rejected":"export function useChatWithCallbacks(url, onFinish, onError) {\n  return useChat({\n    api: url,\n    onFinish: onFinish,\n    onError: onError\n  });\n}"}
{"prompt":"Write code to solve this task:\n\nHandle thinking message parts with special styling\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nglobalThis.renderThinkingPart = (part) => {\n  if (part.type === 'thinking') {\n    return { tag: 'em', prefix: 'ðŸ’­', content: part.content, className: 'italic' };\n  }\n  return null;\n};\n\ntest('renders thinking parts with emoji and styling', () => {\n  const part = { type: 'thinking', content: 'Analyzing the request' };\n  const result = globalThis.renderThinkingPart(part);\n  \n  assert.strictEqual(result.tag, 'em');\n  assert.strictEqual(result.prefix, 'ðŸ’­');\n  assert.strictEqual(result.content, 'Analyzing the request');\n  assert.strictEqual(result.className, 'italic');\n});\n\ntest('returns null for non-thinking parts', () => {\n  const part = { type: 'text', content: 'test' };\n  const result = globalThis.renderThinkingPart(part);\n  \n  assert.strictEqual(result, null);\n});\n```\n\nReturn ONLY the code, no explanations.","chosen":"export function createChatStream(adapter, messages) {\n  return chat({\n    adapter,\n    messages,\n  });\n}","rejected":"export async function* createChatStream(adapter, messages) {\n  const stream = await adapter.chat(messages);\n  for await (const chunk of stream) {\n    yield chunk;\n  }\n}"}
{"prompt":"Write code to solve this task:\n\nMap over message parts and filter by type\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nglobalThis.extractTextContent = (parts) => {\n  return parts\n    .filter(part => part.type === 'text')\n    .map(part => part.content)\n    .join('');\n};\n\ntest('extracts text from mixed message parts', () => {\n  const parts = [\n    { type: 'text', content: 'Hello ' },\n    { type: 'thinking', content: 'processing' },\n    { type: 'text', content: 'world' }\n  ];\n  const result = globalThis.extractTextContent(parts);\n  \n  assert.strictEqual(result, 'Hello world');\n});\n\ntest('returns empty string when no text parts', () => {\n  const parts = [\n    { type: 'thinking', content: 'thinking' },\n    { type: 'tool-call', name: 'test' }\n  ];\n  const result = globalThis.extractTextContent(parts);\n  \n  assert.strictEqual(result, '');\n});\n```\n\nReturn ONLY the code, no explanations.","chosen":"export function createChatHandler(adapter) {\n  return async (request) => {\n    const { messages } = await request.json();\n\n    const stream = chat({\n      adapter,\n      messages,\n    });\n\n    return toServerSentEventsResponse(stream);\n  };\n}","rejected":"export function createChatHandler(adapter) {\n  return async (request) => {\n    const { messages } = await request.json();\n    const result = await adapter.chat({ messages });\n    return adapter.toServerSentEventsResponse(result);\n  };\n}"}
{"prompt":"Write code to solve this task:\n\nValidate message part structure with type guards\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nglobalThis.isTextPart = (part) => {\n  return part && part.type === 'text' && typeof part.content === 'string';\n};\n\nglobalThis.isThinkingPart = (part) => {\n  return part && part.type === 'thinking' && typeof part.content === 'string';\n};\n\ntest('validates text parts correctly', () => {\n  assert.strictEqual(globalThis.isTextPart({ type: 'text', content: 'hi' }), true);\n  assert.strictEqual(globalThis.isTextPart({ type: 'thinking', content: 'hi' }), false);\n  assert.strictEqual(globalThis.isTextPart({ type: 'text' }), false);\n});\n\ntest('validates thinking parts correctly', () => {\n  assert.strictEqual(globalThis.isThinkingPart({ type: 'thinking', content: 'test' }), true);\n  assert.strictEqual(globalThis.isThinkingPart({ type: 'text', content: 'test' }), false);\n  assert.strictEqual(globalThis.isThinkingPart({ type: 'thinking' }), false);\n});\n```\n\nReturn ONLY the code, no explanations.","chosen":"export async function createChatWithTools(adapter, messages, tools) {\n  return chat({\n    adapter,\n    messages,\n    tools,\n  });\n}","rejected":"export async function createChatWithTools(adapter, messages, tools) {\n  return await adapter.chat(messages, tools);\n}"}
{"prompt":"Write code to solve this task:\n\nParse JSON from request body and extract messages\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nglobalThis.parseRequestMessages = async (request) => {\n  const body = await request.json();\n  return body.messages || [];\n};\n\ntest('extracts messages from request body', async () => {\n  const request = {\n    json: async () => ({ messages: [{ role: 'user', content: 'Hi' }] })\n  };\n  const messages = await globalThis.parseRequestMessages(request);\n  \n  assert.strictEqual(messages.length, 1);\n  assert.strictEqual(messages[0].role, 'user');\n  assert.strictEqual(messages[0].content, 'Hi');\n});\n\ntest('returns empty array when no messages', async () => {\n  const request = { json: async () => ({}) };\n  const messages = await globalThis.parseRequestMessages(request);\n  \n  assert.strictEqual(messages.length, 0);\n});\n```\n\nReturn ONLY the code, no explanations.","chosen":"export function createAnthropicAdapter(apiKey, model) {\n  return anthropicText({\n    apiKey: apiKey,\n    model: model\n  });\n}","rejected":"export function createAnthropicAdapter(apiKey, model) {\n  return {\n    anthropicText: async function(config) {\n      return {\n        ...config,\n        apiKey,\n        model\n      };\n    }\n  };\n}"}
{"prompt":"Write code to solve this task:\n\nBuild complete POST handler with chat and SSE conversion\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nlet capturedChatConfig;\nglobalThis.chat = (config) => {\n  capturedChatConfig = config;\n  return { type: 'stream', data: 'chunks' };\n};\n\nglobalThis.toServerSentEventsResponse = (stream) => ({\n  stream,\n  headers: { 'Content-Type': 'text/event-stream' }\n});\n\nglobalThis.POST = async (request) => {\n  const { messages } = await request.json();\n  const adapter = { name: 'openai' };\n  const stream = globalThis.chat({ adapter, messages });\n  return globalThis.toServerSentEventsResponse(stream);\n};\n\ntest('POST handler processes request and returns SSE', async () => {\n  const request = {\n    json: async () => ({ messages: [{ role: 'user', content: 'Hi' }] })\n  };\n  const response = await globalThis.POST(request);\n  \n  assert.strictEqual(response.headers['Content-Type'], 'text/event-stream');\n  assert.strictEqual(capturedChatConfig.messages[0].content, 'Hi');\n});\n\ntest('passes adapter to chat function', async () => {\n  const request = { json: async () => ({ messages: [] }) };\n  await globalThis.POST(request);\n  \n  assert.strictEqual(capturedChatConfig.adapter.name, 'openai');\n});\n```\n\nReturn ONLY the code, no explanations.","chosen":"export function createOllamaAdapter(host, model) {\n  return ollamaText({\n    host: host,\n    model: model\n  });\n}","rejected":"export function createOllamaAdapter(host, model) {\n  return function ollamaText(config = {}) {\n    return {\n      ...config,\n      host,\n      model\n    };\n  };\n}"}
{"prompt":"Write code to solve this task:\n\nCreate OpenAI adapter with API key configuration\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nglobalThis.openaiText = (config) => {\n  return {\n    provider: 'openai',\n    apiKey: typeof config === 'string' ? config : config.apiKey,\n    baseURL: typeof config === 'object' ? config.baseURL : undefined\n  };\n};\n\ntest('creates OpenAI adapter with API key string', () => {\n  const adapter = globalThis.openaiText('sk-test123');\n  \n  assert.strictEqual(adapter.provider, 'openai');\n  assert.strictEqual(adapter.apiKey, 'sk-test123');\n});\n\ntest('creates OpenAI adapter with config object', () => {\n  const adapter = globalThis.openaiText({ apiKey: 'sk-test123' });\n  \n  assert.strictEqual(adapter.provider, 'openai');\n  assert.strictEqual(adapter.apiKey, 'sk-test123');\n});\n```\n\nReturn ONLY the code, no explanations.","chosen":"export function createBasicTool(name, description, inputSchema) {\n  return toolDefinition({\n    name,\n    description,\n    inputSchema,\n  });\n}","rejected":"export function createBasicTool(name, description, inputSchema) {\n  return {\n    name,\n    description,\n    input_schema: inputSchema\n  };\n}"}
{"prompt":"Write code to solve this task:\n\nCreate Ollama adapter with host configuration\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nglobalThis.ollamaText = (config) => {\n  const host = typeof config === 'string' ? config : config?.host;\n  return {\n    provider: 'ollama',\n    host: host || 'http://localhost:11434'\n  };\n};\n\ntest('creates Ollama adapter with default localhost', () => {\n  const adapter = globalThis.ollamaText();\n  \n  assert.strictEqual(adapter.provider, 'ollama');\n  assert.strictEqual(adapter.host, 'http://localhost:11434');\n});\n\ntest('creates Ollama adapter with custom host string', () => {\n  const adapter = globalThis.ollamaText('http://192.168.1.100:11434');\n  \n  assert.strictEqual(adapter.host, 'http://192.168.1.100:11434');\n});\n\ntest('creates Ollama adapter with host in config object', () => {\n  const adapter = globalThis.ollamaText({ host: 'http://server:11434' });\n  \n  assert.strictEqual(adapter.host, 'http://server:11434');\n});\n```\n\nReturn ONLY the code, no explanations.","chosen":"export function createApprovalTool(name, description, inputSchema) {\n  return toolDefinition({\n    name,\n    description,\n    inputSchema,\n    needsApproval: true,\n  });\n}","rejected":"export function createApprovalTool(name, description, inputSchema) {\n  return {\n    name,\n    description,\n    input_schema: inputSchema,\n    needsApproval: true\n  };\n}"}
{"prompt":"Write code to solve this task:\n\nImplement provider selection logic for multi-provider support\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nglobalThis.openaiText = (config) => ({ provider: 'openai', apiKey: config.apiKey });\nglobalThis.anthropicText = (config) => ({ provider: 'anthropic', apiKey: config.apiKey });\nglobalThis.geminiText = (config) => ({ provider: 'gemini', apiKey: config.apiKey });\n\nglobalThis.getAdapter = (provider, apiKey) => {\n  const adapters = {\n    openai: globalThis.openaiText,\n    anthropic: globalThis.anthropicText,\n    gemini: globalThis.geminiText\n  };\n  return adapters[provider]({ apiKey });\n};\n\ntest('selects OpenAI adapter', () => {\n  const adapter = globalThis.getAdapter('openai', 'sk-test');\n  assert.strictEqual(adapter.provider, 'openai');\n});\n\ntest('selects Anthropic adapter', () => {\n  const adapter = globalThis.getAdapter('anthropic', 'sk-ant-test');\n  assert.strictEqual(adapter.provider, 'anthropic');\n});\n\ntest('selects Gemini adapter', () => {\n  const adapter = globalThis.getAdapter('gemini', 'ai-test');\n  assert.strictEqual(adapter.provider, 'gemini');\n});\n```\n\nReturn ONLY the code, no explanations.","chosen":"export function createFullTool(config) {\n  return toolDefinition({\n    name: config.name,\n    description: config.description,\n    inputSchema: config.inputSchema,\n    outputSchema: config.outputSchema,\n  });\n}","rejected":"export function createFullTool(config) {\n  return {\n    name: config.name,\n    description: config.description,\n    inputSchema: config.inputSchema,\n    outputSchema: config.outputSchema\n  };\n}"}
{"prompt":"Write code to solve this task:\n\nCreate a Zod schema for tool input validation\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nglobalThis.z = {\n  object: (shape) => ({ type: 'object', shape }),\n  string: () => ({ type: 'string', describe: (d) => ({ type: 'string', description: d }) }),\n  number: () => ({ type: 'number' }),\n  enum: (values) => ({ type: 'enum', values })\n};\n\nglobalThis.createWeatherInputSchema = () => {\n  return globalThis.z.object({\n    location: globalThis.z.string().describe('City and state'),\n    unit: globalThis.z.enum(['celsius', 'fahrenheit'])\n  });\n};\n\ntest('creates object schema with location and unit', () => {\n  const schema = globalThis.createWeatherInputSchema();\n  \n  assert.strictEqual(schema.type, 'object');\n  assert.ok(schema.shape.location);\n  assert.ok(schema.shape.unit);\n});\n\ntest('location is a string with description', () => {\n  const schema = globalThis.createWeatherInputSchema();\n  \n  assert.strictEqual(schema.shape.location.type, 'string');\n  assert.strictEqual(schema.shape.location.description, 'City and state');\n});\n\ntest('unit is an enum with celsius and fahrenheit', () => {\n  const schema = globalThis.createWeatherInputSchema();\n  \n  assert.strictEqual(schema.shape.unit.type, 'enum');\n  assert.ok(schema.shape.unit.values.includes('celsius'));\n  assert.ok(schema.shape.unit.values.includes('fahrenheit'));\n});\n```\n\nReturn ONLY the code, no explanations.","chosen":"export function countToolCalls(messages) {\n  return messages.reduce((total, message) => {\n    return total + message.parts.filter(part => part.type === \"tool_call\").length;\n  }, 0);\n}","rejected":"export function countToolCalls(messages) {\n  return messages.reduce((count, message) => {\n    if (Array.isArray(message.content)) {\n      return count + message.content.filter(part => part.type === \"tool_call\").length;\n    }\n    return count;\n  }, 0);\n}"}
{"prompt":"Write code to solve this task:\n\nImplement server-side tool execution handler\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nlet fetchCalls = [];\nglobalThis.fetch = async (url) => {\n  fetchCalls.push(url);\n  return {\n    json: async () => ({ temperature: 72, conditions: 'sunny', location: 'SF' })\n  };\n};\n\nglobalThis.getWeatherServer = async ({ location, unit }) => {\n  const response = await globalThis.fetch(`https://api.weather.com/v1/current?location=${location}&unit=${unit || 'fahrenheit'}`);\n  const data = await response.json();\n  return {\n    temperature: data.temperature,\n    conditions: data.conditions,\n    location: data.location\n  };\n};\n\ntest('fetches weather data for location', async () => {\n  fetchCalls = [];\n  const result = await globalThis.getWeatherServer({ location: 'SF, CA', unit: 'celsius' });\n  \n  assert.ok(fetchCalls[0].includes('SF, CA'));\n  assert.ok(fetchCalls[0].includes('celsius'));\n});\n\ntest('returns structured weather data', async () => {\n  const result = await globalThis.getWeatherServer({ location: 'SF, CA' });\n  \n  assert.strictEqual(result.temperature, 72);\n  assert.strictEqual(result.conditions, 'sunny');\n  assert.strictEqual(result.location, 'SF');\n});\n```\n\nReturn ONLY the code, no explanations.","chosen":"export function getToolResults(messages) {\n  const results = [];\n  \n  for (const message of messages) {\n    if (message.parts) {\n      for (const part of message.parts) {\n        if (part.type === 'tool_result') {\n          results.push({\n            name: part.name,\n            result: part.result\n          });\n        }\n      }\n    }\n  }\n  \n  return results;\n}","rejected":"export function getToolResults(messages) {\n  const results = [];\n  \n  for (const message of messages) {\n    if (message.content && Array.isArray(message.content)) {\n      for (const part of message.content) {\n        if (part.type === 'tool_result') {\n          results.push({\n            name: part.tool_use_id || part.name,\n            result: part.content\n          });\n        }\n      }\n    }\n  }\n  \n  return results;\n}"}
{"prompt":"Write code to solve this task:\n\nCreate tool with needsApproval flag for sensitive operations\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nglobalThis.toolDefinition = (config) => config;\n\ntest('creates tool with needsApproval true', () => {\n  const tool = globalThis.toolDefinition({\n    name: 'delete_data',\n    description: 'Delete user data',\n    needsApproval: true,\n    inputSchema: {},\n    outputSchema: {}\n  });\n  \n  assert.strictEqual(tool.needsApproval, true);\n});\n\ntest('creates tool with needsApproval false', () => {\n  const tool = globalThis.toolDefinition({\n    name: 'read_data',\n    description: 'Read data',\n    needsApproval: false,\n    inputSchema: {},\n    outputSchema: {}\n  });\n  \n  assert.strictEqual(tool.needsApproval, false);\n});\n```\n\nReturn ONLY the code, no explanations.","chosen":"export function createSSEConnection(url) {\n  return fetchServerSentEvents(url);\n}","rejected":"export function createSSEConnection(url) {\n  return fetchServerSentEvents(url);\n}\n\nasync function fetchServerSentEvents(url) {\n  const response = await fetch(url);\n  \n  if (!response.ok) {\n    throw new Error(`HTTP error! status: ${response.status}`);\n  }\n  \n  const reader = response.body.getReader();\n  const decoder = new TextDecoder();\n  \n  return {\n    async *[Symbol.asyncIterator]() {\n      let buffer = '';\n      \n      while (true) {\n        const { done, value } = await reader.read();\n        \n        if (done) break;\n        \n        buffer += decoder.decode(value, { stream: true });\n        const lines = buffer.split('\\n');\n        buffer = lines.pop();\n        \n        let event = {};\n        \n        for (const line of lines) {\n          if (line.startsWith('data: ')) {\n            event.data = line.slice(6);\n          } else if (line.startsWith('event: ')) {\n            event.event = line.slice(7);\n          } else if (line.startsWith('id: ')) {\n            event.id = line.slice(4);\n          } else if (line === '') {\n            if (event.data !== undefined) {\n              yield event;\n              event = {};\n            }\n          }\n        }\n      }\n    }\n  };\n}"}
{"prompt":"Write code to solve this task:\n\nImplement fetchServerSentEvents connection adapter\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nlet fetchCalls = [];\nglobalThis.fetch = async (url, options) => {\n  fetchCalls.push({ url, options });\n  return { ok: true, body: 'stream' };\n};\n\nglobalThis.fetchServerSentEvents = (endpoint) => {\n  return async (messages) => {\n    const response = await globalThis.fetch(endpoint, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ messages })\n    });\n    return response.body;\n  };\n};\n\ntest('creates POST connection to endpoint', async () => {\n  fetchCalls = [];\n  const connection = globalThis.fetchServerSentEvents('/api/chat');\n  await connection([{ role: 'user', content: 'Hi' }]);\n  \n  assert.strictEqual(fetchCalls[0].url, '/api/chat');\n  assert.strictEqual(fetchCalls[0].options.method, 'POST');\n});\n\ntest('sends messages as JSON in request body', async () => {\n  fetchCalls = [];\n  const connection = globalThis.fetchServerSentEvents('/api/chat');\n  await connection([{ role: 'user', content: 'Test' }]);\n  \n  const body = JSON.parse(fetchCalls[0].options.body);\n  assert.strictEqual(body.messages[0].content, 'Test');\n});\n\ntest('sets correct content type header', async () => {\n  fetchCalls = [];\n  const connection = globalThis.fetchServerSentEvents('/api/chat');\n  await connection([]);\n  \n  assert.strictEqual(fetchCalls[0].options.headers['Content-Type'], 'application/json');\n});\n```\n\nReturn ONLY the code, no explanations.","chosen":"export function createStreamConnection(serverFn) {\n  return stream(serverFn);\n}","rejected":"export function createStreamConnection(serverFn) {\n  return async function stream(messages, options) {\n    const result = await serverFn(messages, options);\n    \n    return new ReadableStream({\n      async start(controller) {\n        try {\n          if (result && typeof result[Symbol.asyncIterator] === 'function') {\n            for await (const chunk of result) {\n              controller.enqueue(chunk);\n            }\n          } else if (result && typeof result.getReader === 'function') {\n            const reader = result.getReader();\n            while (true) {\n              const { done, value } = await reader.read();\n              if (done) break;\n              controller.enqueue(value);\n            }\n          } else {\n            controller.enqueue(result);\n          }\n          controller.close();\n        } catch (error) {\n          controller.error(error);\n        }\n      }\n    });\n  };\n}"}
{"prompt":"Write code to solve this task:\n\nCreate stream connection adapter for server functions\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\nlet serverFnCalls = [];\nconst mockServerFn = ({ messages }) => {\n  serverFnCalls.push(messages);\n  return { type: 'stream', messages };\n};\n\nglobalThis.stream = (serverFn) => {\n  return (messages) => serverFn({ messages });\n};\n\ntest('wraps server function in connection adapter', () => {\n  serverFnCalls = [];\n  const connection = globalThis.stream(mockServerFn);\n  const result = connection([{ role: 'user', content: 'Hi' }]);\n  \n  assert.strictEqual(serverFnCalls.length, 1);\n  assert.strictEqual(serverFnCalls[0][0].content, 'Hi');\n});\n\ntest('returns server function result', () => {\n  const connection = globalThis.stream(mockServerFn);\n  const result = connection([{ role: 'user', content: 'Test' }]);\n  \n  assert.strictEqual(result.type, 'stream');\n  assert.strictEqual(result.messages[0].content, 'Test');\n});\n```\n\nReturn ONLY the code, no explanations.","chosen":"export function useChatWithConnection(connectionType, endpoint) {\n  if (connectionType === \"sse\") {\n    return useChat({\n      connection: fetchServerSentEvents(endpoint),\n    });\n  } else if (connectionType === \"stream\") {\n    return useChat({\n      connection: stream(endpoint),\n    });\n  }\n}","rejected":"export function useChatWithConnection(connectionType, endpoint) {\n  return async function useChat(message) {\n    if (connectionType === \"sse\") {\n      return await fetchServerSentEvents(endpoint, message);\n    } else if (connectionType === \"stream\") {\n      return await stream(endpoint, message);\n    }\n  };\n}\n\nasync function fetchServerSentEvents(endpoint, message) {\n  const response = await fetch(endpoint, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ message })\n  });\n  \n  const reader = response.body.getReader();\n  const decoder = new TextDecoder();\n  let result = '';\n  \n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) break;\n    result += decoder.decode(value, { stream: true });\n  }\n  \n  return result;\n}\n\nasync function stream(endpoint, message) {\n  const response = await fetch(endpoint, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ message })\n  });\n  \n  const reader = response.body.getReader();\n  const decoder = new TextDecoder();\n  let result = '';\n  \n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) break;\n    result += decoder.decode(value, { stream: true });\n  }\n  \n  return result;\n}"}