{"prompt":"## useChat Hook for Streaming Chat\n\nThe useChat hook from @tanstack/ai-react simplifies building chat interfaces in React by handling message streaming and user interactions. It connects to a server or API endpoint to stream responses in real-time, providing a seamless chat experience. This hook is essential for managing chat state and rendering messages dynamically.\n\n```typescript\nimport { useChat, fetchServerSentEvents } from '@tanstack/ai-react';\nconst chat = useChat({ connection: fetchServerSentEvents('/api/chat') });\n\nconst { messages, sendMessage, isLoading } = useChat({ connection: fetchServerSentEvents('/api/chat') });\n```\n\n---\n\nWrite code to solve this task:\n\nWrite a function to send a message using the useChat hook and handle loading state.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\n// Mock globals\nlet capturedMessage;\nglobalThis.useChat = (config) => ({\n  messages: [],\n  sendMessage: (msg) => { capturedMessage = msg; },\n  isLoading: false\n});\n\ntest('send message using useChat hook', () => {\n  const chat = globalThis.useChat({});\n  const result = sendChatMessage(chat, 'Hello AI');\n  assert.strictEqual(capturedMessage, 'Hello AI');\n  assert.strictEqual(result, true);\n});\n\nfunction sendChatMessage(chat, message) {\n  if (!chat.isLoading) {\n    chat.sendMessage(message);\n    return true;\n  }\n  return false;\n}\n```\n\nReturn ONLY the code, no explanations.","chosen":"export function sendMessageToChat(chat, message) {\n  if (!chat.isLoading) {\n    chat.sendMessage(message);\n    return true;\n  }\n  return false;\n}","rejected":"export function sendChatMessage(message) {\n  const { sendMessage, isLoading } = useChat({ connection: fetchServerSentEvents('/api/chat') });\n  \n  return {\n    send: async () => {\n      if (!isLoading) {\n        await sendMessage(message);\n      }\n      return { success: !isLoading };\n    },\n    isLoading\n  };\n}","rejected_error":"Identifier 'sendChatMessage' has already been declared"}
{"prompt":"## Server-Side Chat with Streaming SSE\n\nTanStack AI supports server-side chat functionality with Server-Sent Events (SSE) for real-time streaming of responses. Using the stream utility or fetchServerSentEvents, you can connect to a server endpoint that handles chat logic and streams AI responses back to the client. This approach is ideal for offloading processing to the server.\n\n```typescript\nimport { useChat, stream } from '@tanstack/ai-react';\nconst chat = useChat({ connection: stream((messages) => serverChatFunction({ messages })) });\n\nimport { fetchServerSentEvents } from '@tanstack/ai-react';\nconst connection = fetchServerSentEvents('/api/chat');\n```\n\n---\n\nWrite code to solve this task:\n\nWrite a function to set up a server-side chat connection using the stream utility.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\n// Mock globals\nlet capturedStreamFn;\nglobalThis.stream = (fn) => { capturedStreamFn = fn; return { type: 'stream' }; };\nglobalThis.useChat = (config) => ({ messages: [], sendMessage: () => {}, isLoading: false });\n\ntest('setup server-side chat with stream utility', () => {\n  const chat = setupServerChat();\n  assert.ok(capturedStreamFn);\n  assert.strictEqual(chat.messages.length, 0);\n});\n\nfunction setupServerChat() {\n  return globalThis.useChat({\n    connection: globalThis.stream((messages) => ({ messages }))\n  });\n}\n```\n\nReturn ONLY the code, no explanations.","chosen":"export function setupServerChatConnection(messages) {\n  return stream((msgs) => serverChatFunction({ messages: msgs }))(messages);\n}","rejected":"export async function setupServerChat(messages) {\n  return stream((msgs) => serverChatFunction({ messages: msgs }))(messages);\n}","rejected_error":"Identifier 'setupServerChat' has already been declared"}
{"prompt":"## Tool Definition and Function Calling\n\nTanStack AI enables defining tools for AI models to call external functions using the toolDefinition utility. Tools are defined with schemas (often using Zod) to validate inputs, allowing the AI to interact with custom logic like fetching weather data. This is powerful for extending AI capabilities with structured function calls.\n\n```typescript\nimport { toolDefinition } from '@tanstack/ai';\nimport { z } from 'zod';\nconst getWeatherDef = toolDefinition({ name: 'get_weather', description: 'Get weather', inputSchema: z.object({ location: z.string() }) });\n\nconst getWeather = getWeatherDef.server(async ({ location }) => ({ temperature: 72, conditions: 'sunny' }));\n```\n\n---\n\nWrite code to solve this task:\n\nWrite a function to define a simple tool using toolDefinition with Zod schema.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\n// Mock globals\nlet capturedTool;\nglobalThis.toolDefinition = (config) => { capturedTool = config; return { name: config.name }; };\nglobalThis.z = { object: (schema) => schema, string: () => ({}) };\n\ntest('define a tool with toolDefinition and Zod schema', () => {\n  const tool = defineWeatherTool();\n  assert.strictEqual(capturedTool.name, 'get_weather');\n  assert.ok(capturedTool.inputSchema.location);\n});\n\nfunction defineWeatherTool() {\n  return globalThis.toolDefinition({\n    name: 'get_weather',\n    description: 'Get current weather',\n    inputSchema: globalThis.z.object({ location: globalThis.z.string() })\n  });\n}\n```\n\nReturn ONLY the code, no explanations.","chosen":"export function createWeatherTool() {\n  return toolDefinition({\n    name: 'get_weather',\n    description: 'Get current weather',\n    inputSchema: z.object({ location: z.string() })\n  });\n}","rejected":"export function defineWeatherTool() {\n  const weatherToolDef = toolDefinition({\n    name: 'get_weather',\n    description: 'Fetch current weather information for a specified location',\n    inputSchema: z.object({\n      location: z.string().describe('The city or location to get weather for')\n    })\n  });\n\n  return weatherToolDef.server(async ({ location }) => {\n    return {\n      temperature: 72,\n      conditions: 'sunny',\n      location\n    };\n  });\n}","rejected_error":"Identifier 'defineWeatherTool' has already been declared"}
{"prompt":"## Message Parts Structure\n\nMessages in TanStack AI are composed of parts that can represent different types of content such as text, thinking, or tool calls. This structure allows for rich chat interactions where the AI's reasoning process or function calls can be displayed distinctly. Understanding message parts is key to rendering complex chat UIs.\n\n```typescript\nmessage.parts.map((part, idx) => part.type === 'text' ? <span key={idx}>{part.content}</span> : null);\n\nmessage.parts.map((part, idx) => part.type === 'thinking' ? <div key={idx}>Thinking: {part.content}</div> : null);\n```\n\n---\n\nWrite code to solve this task:\n\nWrite a function to extract text content from message parts.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\ntest('extract text content from message parts', () => {\n  const message = {\n    parts: [\n      { type: 'text', content: 'Hello' },\n      { type: 'thinking', content: 'Thinking...' }\n    ]\n  };\n  const text = extractTextContent(message);\n  assert.strictEqual(text, 'Hello');\n});\n\nfunction extractTextContent(message) {\n  const textPart = message.parts.find(part => part.type === 'text');\n  return textPart ? textPart.content : '';\n}\n```\n\nReturn ONLY the code, no explanations.","chosen":"function getTextContent(message) {\n  return message.parts\n    .filter(part => part.type === 'text')\n    .map(part => part.content)\n    .join(' ');\n}","rejected":"export function extractTextContent(parts) {\n  return parts\n    .filter(part => part.type === 'text')\n    .map(part => part.content)\n    .join(' ');\n}","rejected_error":"Identifier 'extractTextContent' has already been declared"}
{"prompt":"## Message Parts Structure\n\nMessages in TanStack AI are composed of parts that can represent different types of content such as text, thinking, or tool calls. This structure allows for rich chat interactions where the AI's reasoning process or function calls can be displayed distinctly. Understanding message parts is key to rendering complex chat UIs.\n\n```typescript\nmessage.parts.map((part, idx) => part.type === 'text' ? <span key={idx}>{part.content}</span> : null);\n\nmessage.parts.map((part, idx) => part.type === 'thinking' ? <div key={idx}>Thinking: {part.content}</div> : null);\n```\n\n---\n\nWrite code to solve this task:\n\nWrite a function to render thinking parts of a message as italic text.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\ntest('render thinking parts as italic text', () => {\n  const message = {\n    parts: [\n      { type: 'text', content: 'Hello' },\n      { type: 'thinking', content: 'Thinking...' }\n    ]\n  };\n  const thinking = renderThinking(message);\n  assert.strictEqual(thinking, '<i>Thinking...</i>');\n});\n\nfunction renderThinking(message) {\n  const thinkingPart = message.parts.find(part => part.type === 'thinking');\n  return thinkingPart ? `<i>${thinkingPart.content}</i>` : '';\n}\n```\n\nReturn ONLY the code, no explanations.","chosen":"export function renderThinkingParts(parts) {\n  return parts\n    .filter(part => part.type === 'thinking')\n    .map(part => `<i>${part.content}</i>`)\n    .join('');\n}","rejected":"export function renderThinkingParts(parts) {\n  return parts.map((part, idx) => \n    part.type === 'thinking' ? <i key={idx}>{part.content}</i> : null\n  );\n}","rejected_error":"Unexpected token '<'"}
{"prompt":"## Message Parts Structure\n\nMessages in TanStack AI are composed of parts that can represent different types of content such as text, thinking, or tool calls. This structure allows for rich chat interactions where the AI's reasoning process or function calls can be displayed distinctly. Understanding message parts is key to rendering complex chat UIs.\n\n```typescript\nmessage.parts.map((part, idx) => part.type === 'text' ? <span key={idx}>{part.content}</span> : null);\n\nmessage.parts.map((part, idx) => part.type === 'thinking' ? <div key={idx}>Thinking: {part.content}</div> : null);\n```\n\n---\n\nWrite code to solve this task:\n\nWrite a function to handle all message part types with custom formatting.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert';\n\ntest('handle all message part types with formatting', () => {\n  const message = {\n    parts: [\n      { type: 'text', content: 'Hello' },\n      { type: 'thinking', content: 'Thinking...' },\n      { type: 'tool_call', content: 'Calling tool' }\n    ]\n  };\n  const formatted = formatMessageParts(message);\n  assert.strictEqual(formatted.length, 3);\n  assert.strictEqual(formatted[0], 'Hello');\n  assert.strictEqual(formatted[1], 'Thinking: Thinking...');\n  assert.strictEqual(formatted[2], 'Tool: Calling tool');\n});\n\nfunction formatMessageParts(message) {\n  return message.parts.map(part => {\n    if (part.type === 'text') return part.content;\n    if (part.type === 'thinking') return `Thinking: ${part.content}`;\n    if (part.type === 'tool_call') return `Tool: ${part.content}`;\n    return '';\n  }).filter(Boolean);\n}\n```\n\nReturn ONLY the code, no explanations.","chosen":"export function formatMessageContent(message) {\n  return message.parts.map((part) => {\n    switch (part.type) {\n      case 'text':\n        return part.content;\n      case 'thinking':\n        return `Thinking: ${part.content}`;\n      case 'tool_call':\n        return `Tool: ${part.content}`;\n      default:\n        return '';\n    }\n  }).filter(Boolean);\n}","rejected":"export function formatMessageParts(parts) {\n  return parts.map((part, idx) => {\n    switch (part.type) {\n      case 'text':\n        return <span key={idx}>{part.content}</span>;\n      case 'thinking':\n        return <div key={idx}>Thinking: {part.content}</div>;\n      case 'tool_call':\n        return <div key={idx}>Tool Call: {JSON.stringify(part.content)}</div>;\n      default:\n        return null;\n    }\n  });\n}","rejected_error":"Unexpected token '<'"}