{"prompt":"Write code to solve this task:\n\nWrite a function `getNodeCount` that takes a `reactFlowInstance` and returns the number of nodes using `getNodes()`.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert/strict';\n\ntest('getNodeCount works', () => {\n  const mockInstance = {\n    getNodes: () => [{ id: '1' }, { id: '2' }]\n  };\n  const result = getNodeCount(mockInstance);\n  assert.strictEqual(result, 2);\n});\n```\n\nReturn ONLY the code, no explanations.","chosen":"export function getNodeCount(reactFlowInstance) {\n  return reactFlowInstance.getNodes().length;\n}","rejected":"export async function getNodeCount(reactFlowInstance) {\n  const nodes = reactFlowInstance.getNodes();\n  return nodes.length;\n}"}
{"prompt":"Write code to solve this task:\n\nWrite a function `createNodeHandlers` that initializes nodes state with given initialNodes and returns {onNodesChange, setNodes}.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert/strict';\n\nlet capturedNodesInit;\nconst useNodesState = (init) => {\n  capturedNodesInit = init;\n  return [[], () => {}, (changes) => {}];\n};\n\nglobalThis.useNodesState = useNodesState;\n\nconst initialNodes = [{id: '1'}];\n\ntest('createNodeHandlers captures initialNodes', () => {\n  const {onNodesChange, setNodes} = createNodeHandlers(initialNodes);\n  assert.deepStrictEqual(capturedNodesInit, initialNodes);\n  assert.strictEqual(typeof onNodesChange, 'function');\n  assert.strictEqual(typeof setNodes, 'function');\n});\n```\n\nReturn ONLY the code, no explanations.","chosen":"export function createNodeHandlers(initialNodes) {\n  const [, setNodes, onNodesChange] = useNodesState(initialNodes);\n  return { onNodesChange, setNodes };\n}","rejected":"export function createNodeHandlers(initialNodes) {\n  let nodes = initialNodes;\n  const listeners = [];\n\n  const onNodesChange = (callback) => {\n    const listener = (currentNodes) => callback(currentNodes);\n    listeners.push(listener);\n    listener(nodes); // immediate invocation with current state\n    return () => {\n      const index = listeners.indexOf(listener);\n      if (index !== -1) {\n        listeners.splice(index, 1);\n      }\n    };\n  };\n\n  const setNodes = async (updaterOrNodes) => {\n    const newNodes = typeof updaterOrNodes === 'function' \n      ? updaterOrNodes(nodes) \n      : updaterOrNodes;\n    nodes = newNodes;\n    const promises = listeners.map(listener => {\n      try {\n        const result = listener(nodes);\n        return result instanceof Promise ? result : Promise.resolve(result);\n      } catch (error) {\n        console.error(error);\n        return Promise.resolve();\n      }\n    });\n    await Promise.all(promises);\n  };\n\n  return { onNodesChange, setNodes };\n}"}
{"prompt":"Write code to solve this task:\n\nWrite a function `basicReactFlowProps` that returns props object for basic ReactFlow with nodes and edges.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert/strict';\n\nconst nodes = []; const edges = [];\n\ntest('basicReactFlowProps includes nodes and edges', () => {\n  const props = basicReactFlowProps(nodes, edges);\n  assert.strictEqual(props.nodes, nodes);\n  assert.strictEqual(props.edges, edges);\n});\n```\n\nReturn ONLY the code, no explanations.","chosen":"export function basicReactFlowProps(nodes, edges) {\n  return {\n    nodes,\n    edges,\n    onNodesChange: () => {},\n    onEdgesChange: () => {},\n    fitView: true\n  };\n}","rejected":"export function basicReactFlowProps() {\n  return {\n    nodes: [\n      {\n        id: '1',\n        type: 'input',\n        data: { label: 'Input Node' },\n        position: { x: 250, y: 25 },\n      },\n      {\n        id: '2',\n        data: { label: 'Default Node' },\n        position: { x: 100, y: 125 },\n      },\n    ],\n    edges: [\n      { id: 'e1-2', source: '1', target: '2' },\n    ],\n  };\n}"}
{"prompt":"Write code to solve this task:\n\nWrite a function `fullReactFlowConfig` that takes nodes, edges, handlers and returns complete props including fitView: true.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert/strict';\n\nconst nodes = []; const edges = [];\nconst onNodesChange = () => {}; const onEdgesChange = () => {};\n\ntest('fullReactFlowConfig has all props', () => {\n  const props = fullReactFlowConfig(nodes, edges, onNodesChange, onEdgesChange);\n  assert.strictEqual(props.nodes, nodes);\n  assert.strictEqual(props.edges, edges);\n  assert.strictEqual(props.onNodesChange, onNodesChange);\n  assert.strictEqual(props.onEdgesChange, onEdgesChange);\n  assert.strictEqual(props.fitView, true);\n});\n```\n\nReturn ONLY the code, no explanations.","chosen":"export function fullReactFlowConfig(nodes, edges, onNodesChange, onEdgesChange) {\n  return {\n    nodes,\n    edges,\n    onNodesChange,\n    onEdgesChange,\n    fitView: true\n  };\n}","rejected":"export function fullReactFlowConfig(nodes, edges, handlers) {\n  return {\n    nodes,\n    edges,\n    ...handlers,\n    fitView: true,\n  };\n}"}
{"prompt":"Write code to solve this task:\n\nWrite a function `addNewEdge` that takes oldEdges and connection, calls addEdge and returns result.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert/strict';\n\nlet capturedConn, capturedEds;\nconst addEdge = (conn, eds) => {\n  capturedConn = conn;\n  capturedEds = eds;\n  return [...eds, {id: 'new', ...conn}];\n};\nglobalThis.addEdge = addEdge;\n\nconst connection = {source: '1', target: '2'};\nconst oldEdges = [];\n\ntest('addNewEdge uses addEdge', () => {\n  const result = addNewEdge(oldEdges, connection);\n  assert.deepStrictEqual(capturedConn, connection);\n  assert.strictEqual(capturedEds, oldEdges);\n  assert.strictEqual(result.length, 1);\n});\n```\n\nReturn ONLY the code, no explanations.","chosen":"export function addNewEdge(oldEdges, connection) {\n  return addEdge(connection, oldEdges);\n}","rejected":"export async function addNewEdge(oldEdges, connection) {\n  return await addEdge(oldEdges, connection);\n}"}
{"prompt":"Write code to solve this task:\n\nWrite a function `safeAddEdge` that uses addEdge in a setEdges updater function.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert/strict';\n\nlet capturedConn, capturedEds, updaterCalled;\nconst addEdge = (conn, eds) => {\n  capturedConn = conn;\n  capturedEds = eds;\n  return [...eds, {id: 'new', ...conn}];\n};\nglobalThis.addEdge = addEdge;\n\nconst connection = {source: '1', target: '2'};\n\ntest('safeAddEdge returns updater', () => {\n  const updater = safeAddEdge(connection);\n  assert.strictEqual(typeof updater, 'function');\n  const newEdges = updater([]);\n  assert.deepStrictEqual(capturedConn, connection);\n  assert.deepStrictEqual(capturedEds, []);\n  assert.strictEqual(newEdges.length, 1);\n});\n```\n\nReturn ONLY the code, no explanations.","chosen":"export function safeAddEdge(connection) {\n  return (eds) => addEdge(connection, eds);\n}","rejected":"export const safeAddEdge = (edge, setEdges) => {\n  setEdges((prevEdges) => addEdge(edge, prevEdges));\n};"}
{"prompt":"Write code to solve this task:\n\nWrite a function `logConnection` that logs the source and target from connection.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert/strict';\n\nlet logArgs;\nconst consoleLog = (...args) => { logArgs = args; };\nglobalThis.console = { log: consoleLog };\n\nconst connection = {source: '1', target: '2'};\n\ntest('logConnection logs source -> target', () => {\n  logConnection(connection);\n  assert.deepStrictEqual(logArgs, ['1', '->', '2']);\n});\n```\n\nReturn ONLY the code, no explanations.","chosen":"export function logConnection(connection) {\n  console.log(connection.source, '->', connection.target);\n}","rejected":"export async function logConnection({ source, target }) {\n  console.log(source, target);\n}"}
{"prompt":"Write code to solve this task:\n\nWrite `createOnConnect` that returns an onConnect handler using addEdge with setEdges.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert/strict';\n\nlet capturedUpdater;\nlet addEdgeCalled = false;\nconst addEdge = () => { addEdgeCalled = true; return []; };\nglobalThis.addEdge = addEdge;\nconst setEdges = (updater) => { capturedUpdater = updater; };\n\ntest('createOnConnect uses addEdge', () => {\n  const onConnect = createOnConnect(setEdges);\n  const conn = {source:'1',target:'2'};\n  onConnect(conn);\n  const newEds = capturedUpdater([]);\n  assert.strictEqual(addEdgeCalled, true);\n});\n```\n\nReturn ONLY the code, no explanations.","chosen":"export const createOnConnect = (setEdges) => {\n  return (connection) => {\n    console.log(connection.source, '->', connection.target);\n    setEdges((eds) => addEdge(connection, eds));\n  };\n};","rejected":"export function createOnConnect(setEdges, addEdge) {\n  return (connection) => {\n    setEdges((edges) => addEdge(connection, edges));\n  };\n}"}
{"prompt":"Write code to solve this task:\n\nWrite `buildCustomNode` that returns node object with type 'custom' and given data.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert/strict';\n\ntest('buildCustomNode has type custom', () => {\n  const node = buildCustomNode({label: 'Test'}, '1');\n  assert.strictEqual(node.type, 'custom');\n  assert.strictEqual(node.id, '1');\n  assert.deepStrictEqual(node.data, {label: 'Test'});\n});\n```\n\nReturn ONLY the code, no explanations.","chosen":"export function buildCustomNode(data, id) {\n  return {\n    id,\n    type: 'custom',\n    data\n  };\n}","rejected":"export function buildCustomNode(data) {\n  return {\n    type: 'custom',\n    data\n  };\n}"}
{"prompt":"Write code to solve this task:\n\nWrite `fullCustomSetup` that returns {nodeTypes, initialNodes} with custom type.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert/strict';\n\nconst CustomNode = () => {};\n\ntest('fullCustomSetup provides both', () => {\n  const setup = fullCustomSetup(CustomNode);\n  assert.strictEqual(setup.nodeTypes.custom, CustomNode);\n  assert.strictEqual(setup.initialNodes[0].type, 'custom');\n});\n```\n\nReturn ONLY the code, no explanations.","chosen":"export function fullCustomSetup(CustomNode) {\n  const nodeTypes = { custom: CustomNode };\n\n  const initialNodes = [\n    { id: '1', type: 'custom', position: { x: 0, y: 0 }, data: { label: 'Node' } }\n  ];\n\n  return { nodeTypes, initialNodes };\n}","rejected":"export function fullCustomSetup() {\n  const nodeTypes = {\n    custom: {\n      type: 'custom',\n      label: 'Custom Node',\n      properties: {\n        color: '#ff6b6b'\n      }\n    }\n  };\n\n  const initialNodes = [\n    {\n      id: '1',\n      type: 'custom',\n      data: { label: 'Hello Custom Node!' },\n      position: { x: 100, y: 100 }\n    },\n    {\n      id: '2',\n      type: 'custom',\n      data: { label: 'Another Custom Node' },\n      position: { x: 400, y: 100 }\n    }\n  ];\n\n  return { nodeTypes, initialNodes };\n}"}
{"prompt":"Write code to solve this task:\n\nWrite `nodeCountDisplay` that uses useNodes() to return count string.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert/strict';\n\nlet capturedNodes;\nconst useNodes = () => {\n  return capturedNodes || [];\n};\nglobalThis.useNodes = useNodes;\n\ntest('nodeCountDisplay returns length string', () => {\n  capturedNodes = [{id:'1'}, {id:'2'}];\n  const result = nodeCountDisplay();\n  assert.strictEqual(result, '2 nodes');\n});\n```\n\nReturn ONLY the code, no explanations.","chosen":"export function nodeCountDisplay() {\n  const nodes = useNodes();\n  return `${nodes.length} nodes`;\n}","rejected":"export async function nodeCountDisplay() {\n  const nodes = await useNodes();\n  return `${nodes.length} nodes`;\n}"}
{"prompt":"Write code to solve this task:\n\nWrite `listNodeIds` that uses useNodes to return array of ids.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert/strict';\n\nlet capturedNodes;\nconst useNodes = () => capturedNodes;\nglobalThis.useNodes = useNodes;\n\ntest('listNodeIds maps ids', () => {\n  capturedNodes = [{id:'1'}, {id:'2'}];\n  const result = listNodeIds();\n  assert.deepStrictEqual(result, ['1', '2']);\n});\n```\n\nReturn ONLY the code, no explanations.","chosen":"export function listNodeIds() {\n  const nodes = useNodes();\n  return nodes.map((node) => node.id);\n}","rejected":"export async function listNodeIds() {\n  const nodes = await useNodes();\n  return nodes.map(node => node.id);\n}"}
{"prompt":"Write code to solve this task:\n\nWrite `combinedStateInit` that inits both nodes and edges state.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert/strict';\n\nlet nodesInit, edgesInit;\nconst useNodesState = (init) => { nodesInit = init; return []; };\nconst useEdgesState = (init) => { edgesInit = init; return []; };\nglobalThis.useNodesState = useNodesState;\nglobalThis.useEdgesState = useEdgesState;\n\ntest('combinedStateInit captures both', () => {\n  combinedStateInit([{id:'n1'}], [{id:'e1'}]);\n  assert.deepStrictEqual(nodesInit, [{id:'n1'}]);\n  assert.deepStrictEqual(edgesInit, [{id:'e1'}]);\n});\n```\n\nReturn ONLY the code, no explanations.","chosen":"export function combinedStateInit(initialNodes, initialEdges) {\n  const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);\n  const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);\n  return [nodes, setNodes, onNodesChange, edges, setEdges, onEdgesChange];\n}","rejected":"export async function combinedStateInit() {\n  return {\n    nodes: [],\n    edges: []\n  };\n}"}
{"prompt":"Write code to solve this task:\n\nWrite `reactFlowWithTypes` that returns props including nodeTypes and edgeTypes.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert/strict';\n\nconst CustomNode = {}; const CustomEdge = {};\n\ntest('reactFlowWithTypes includes types', () => {\n  const props = reactFlowWithTypes(CustomNode, CustomEdge, [], []);\n  assert.strictEqual(props.nodeTypes.custom, CustomNode);\n  assert.strictEqual(props.edgeTypes.custom, CustomEdge);\n});\n```\n\nReturn ONLY the code, no explanations.","chosen":"export function reactFlowWithTypes(CustomNode, CustomEdge, nodes, edges) {\n  return {\n    nodes,\n    edges,\n    onNodesChange: () => {},\n    onEdgesChange: () => {},\n    fitView: true,\n    nodeTypes: { custom: CustomNode },\n    edgeTypes: { custom: CustomEdge }\n  };\n}","rejected":"export default async function reactFlowWithTypes() {\n  return {\n    nodeTypes: {},\n    edgeTypes: {},\n  };\n}"}
{"prompt":"Write code to solve this task:\n\nWrite `batchAddEdges` that adds multiple connections using addEdge sequentially.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert/strict';\n\nlet addEdgeCalls = [];\nconst addEdge = (conn) => {\n  addEdgeCalls.push(conn);\n  return [];\n};\nglobalThis.addEdge = addEdge;\n\nconst conns = [{source:'1',target:'2'}, {source:'3',target:'4'}];\n\ntest('batchAddEdges calls addEdge for each', () => {\n  const updater = batchAddEdges(conns);\n  updater([]);\n  assert.strictEqual(addEdgeCalls.length, 2);\n  assert.deepStrictEqual(addEdgeCalls[0], conns[0]);\n});\n```\n\nReturn ONLY the code, no explanations.","chosen":"export function batchAddEdges(connections) {\n  return (edges) => connections.reduce((currentEdges, connection) => addEdge(connection, currentEdges), edges);\n}","rejected":"export async function batchAddEdges(addEdge, edges) {\n  for (const edge of edges) {\n    await addEdge(edge);\n  }\n}"}
{"prompt":"Write code to solve this task:\n\nWrite `filteredNodes` that uses useNodes to return only selected nodes.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert/strict';\n\nconst useNodes = () => [{id:'1', selected: true}, {id:'2', selected: false}];\nglobalThis.useNodes = useNodes;\n\ntest('filteredNodes returns selected', () => {\n  const result = filteredNodes();\n  assert.strictEqual(result.length, 1);\n  assert.strictEqual(result[0].id, '1');\n});\n```\n\nReturn ONLY the code, no explanations.","chosen":"export const filteredNodes = () => {\n  const nodes = useNodes();\n  return nodes.filter((node) => node.selected);\n};","rejected":"export async function filteredNodes(selectedIds) {\n  const nodes = await useNodes();\n  return nodes.filter(({ id }) => selectedIds.includes(id));\n}"}
{"prompt":"Write code to solve this task:\n\nWrite `connectWithHandles` that logs handles if present in connection.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert/strict';\n\nlet logArgs = [];\nconst consoleLog = (...a) => logArgs.push(a);\nglobalThis.console = {log: consoleLog};\n\ntest('connectWithHandles logs handles', () => {\n  const conn = {source:'1', target:'2', sourceHandle:'a', targetHandle:'b'};\n  connectWithHandles()(conn);\n  assert.deepStrictEqual(logArgs[0], ['a', '->', 'b']);\n});\n```\n\nReturn ONLY the code, no explanations.","chosen":"export const connectWithHandles = () => (connection) => {\n  console.log(connection.sourceHandle, '->', connection.targetHandle);\n};","rejected":"export async function connectWithHandles(connection) {\n  if (connection?.handles) {\n    console.log(connection.handles);\n  }\n}"}
{"prompt":"Write code to solve this task:\n\nWrite `minimalReactFlow` that returns props with defaultNodes and defaultEdges.\n\nYour code will be tested with this test file:\n\n```typescript\nimport { test } from 'node:test';\nimport assert from 'node:assert/strict';\n\ntest('minimalReactFlow uses default props', () => {\n  const props = minimalReactFlow();\n  assert.ok(Array.isArray(props.defaultNodes));\n  assert.ok(Array.isArray(props.defaultEdges));\n});\n```\n\nReturn ONLY the code, no explanations.","chosen":"export function minimalReactFlow() {\n  return {\n    defaultNodes: [\n      {\n        id: '1',\n        data: { label: 'Node 1' },\n        position: { x: 250, y: 25 },\n      },\n      {\n        id: '2',\n        data: { label: 'Node 2' },\n        position: { x: 100, y: 125 },\n      },\n    ],\n    defaultEdges: [\n      {\n        id: 'e1-2',\n        source: '1',\n        target: '2',\n      },\n    ],\n  };\n}","rejected":"export async function minimalReactFlow() {\n  return {\n    defaultNodes: [\n      {\n        id: '1',\n        data: { label: 'Node 1' },\n        position: { x: 250, y: 25 }\n      },\n      {\n        id: '2',\n        data: { label: 'Node 2' },\n        position: { x: 100, y: 125 }\n      }\n    ],\n    defaultEdges: [\n      {\n        id: 'e1-2',\n        source: '1',\n        target: '2'\n      }\n    ]\n  };\n}"}